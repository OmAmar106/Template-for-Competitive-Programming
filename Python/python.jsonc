{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
    "cp": {
        "prefix": "cp",
        "body": [
            "import sys,math,cmath,random,os",
            "from heapq import heappush,heappop",
            "from bisect import bisect_right,bisect_left",
            "from collections import Counter,deque,defaultdict",
            "from itertools import permutations,combinations",
            "from io import BytesIO, IOBase",
            "from decimal import Decimal,getcontext",
            "",
            "BUFSIZE = 8192",
            "class FastIO(IOBase):",
            "\tnewlines = 0",
            "\tdef __init__(self, file):",
            "\t\tself._file = file",
            "\t\tself._fd = file.fileno()",
            "\t\tself.buffer = BytesIO()",
            "\t\tself.writable = \"x\" in file.mode or \"r\" not in file.mode",
            "\t\tself.write = self.buffer.write if self.writable else None",
            "\tdef read(self):",
            "\t\twhile True:",
            "\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "\t\t\tif not b:",
            "\t\t\t\tbreak",
            "\t\t\tptr = self.buffer.tell()",
            "\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "\t\tself.newlines = 0",
            "\t\treturn self.buffer.read()",
            "\tdef readline(self):",
            "\t\twhile self.newlines == 0:",
            "\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "\t\t\tself.newlines = b.count(b\"\\n\") + (not b)",
            "\t\t\tptr = self.buffer.tell()",
            "\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "\t\tself.newlines -= 1",
            "\t\treturn self.buffer.readline()",
            "\tdef flush(self):",
            "\t\tif self.writable:",
            "\t\t\tos.write(self._fd, self.buffer.getvalue())",
            "\t\t\tself.buffer.truncate(0), self.buffer.seek(0)",
            "class IOWrapper(IOBase):",
            "\tdef __init__(self, file):",
            "\t\tself.buffer = FastIO(file)",
            "\t\tself.flush = self.buffer.flush",
            "\t\tself.writable = self.buffer.writable",
            "\t\tself.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
            "\t\tself.read = lambda: self.buffer.read().decode(\"ascii\")",
            "\t\tself.readline = lambda: self.buffer.readline().decode(\"ascii\")",
            "sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
            "",
            "# functions #",
            "# MOD = 998244353",
            "MOD = 10**9 + 7",
            "RANDOM = random.randrange(1,2**62)",
            "def gcd(a,b):",
            "\twhile b:",
            "\t\ta,b = b,a%b",
            "\treturn a",
            "def lcm(a,b):",
            "\treturn a//gcd(a,b)*b",
            "def w(x):",
            "\treturn x ^ RANDOM",
            "II = lambda : int(sys.stdin.readline().strip())",
            "LII = lambda : list(map(int, sys.stdin.readline().split()))",
            "MI = lambda x : x(map(int, sys.stdin.readline().split()))",
            "SI = lambda : sys.stdin.readline().strip()",
            "SLI = lambda : list(map(lambda x:ord(x)-97,sys.stdin.readline().strip()))",
            "LII_1 = lambda : list(map(lambda x:int(x)-1, sys.stdin.readline().split()))",
            "LII_C = lambda x : list(map(x, sys.stdin.readline().split()))",
            "MATI = lambda x : [list(map(int, sys.stdin.readline().split())) for _ in range(x)]",
            "##",
            "",
            "#String hashing: shclass, fenwick sortedlist: fsortl, Number: numtheory/numrare, SparseTable: SparseTable",
            "#Bucket Sorted list: bsortl, Segment Tree(lp,selfop): SegmentTree, bootstrap: bootstrap, Trie: tries",
            "#binary indexed tree: BIT, Segment Tree(point updates): SegmentPoint, Convex Hull: hull, BitArray: bitarray",
            "#Combinatorics: pnc, Diophantine Equations: dpheq, DSU: DSU, Geometry: Geometry, FFT: fft, XOR_dict: xdict",
            "#Persistent Segment Tree: perseg, Binary Trie: b_trie, HLD: hld, String funcs: sf, Segment Tree(lp): SegmentOther",
            "#Graph1(dnc,bl): graphadv, Graph2(khn,sat): 2sat, Graph3(fltn,bprt): graphflatten, Graph4(ep,tp,fw,bmf): graphoth",
            "#Graph5(djik,bfs,dfs): graph, Graph6(dfsin): dfsin, utils: utils, Persistent DSU: perdsu, Merge Sort Tree: sorttree",
            "#2-D BIT: 2DBIT, MonoDeque: mono, matrix: nummat, SuffixAutomaton: sautomaton, linalg: linalg, SquareRtDecomp: sqrt",
            "#Grapth7(bridges): graph_dmgt, FWHT(^,|,&): fwht, Graph8(centr_decom): graph_decom, DpOptimize(knth,dnc): dpopt",
            "2D-SegmentTree: seg2d, Rollback/Par DSU: rbdsu",
            "#Template : https://github.com/OmAmar106/Template-for-Competetive-Programming",
            "#if os.environ.get('LOCAL'):sys.stdin = open(r'input.txt', 'r');sys.stdout = sys.stderr = open(r'output.txt','w')",
            "#if os.environ.get('LOCAL'):import hashlib;print('Hash Value :',hashlib.md5(open(__file__, 'rb').read()).hexdigest());",
            "",
            "def solve():",
            "\tn = II()",
            "\tL = LII()",
            "\t#L1 = LII()",
            "\t#st = SI()",
            "for _ in range(II()):",
            "\t#if os.environ.get('LOCAL'):print('________________'+'Test Case : '+str(_+1)+'________________\\n')",
            "\tsolve()"
        ],
        "description": "cp implementation"
    },
    "tcp": {
		"prefix": "tcp",
		"body": [
			"import sys,math,cmath,random,os",
            "from heapq import heappush,heappop",
            "from bisect import bisect_right,bisect_left",
            "from collections import Counter,deque,defaultdict",
            "from itertools import permutations,combinations",
            "from io import BytesIO, IOBase",
            "from decimal import Decimal,getcontext",
            "",
            "BUFSIZE = 8192",
            "class FastIO(IOBase):",
            "\tnewlines = 0",
            "\tdef __init__(self, file):",
            "\t\tself._file = file",
            "\t\tself._fd = file.fileno()",
            "\t\tself.buffer = BytesIO()",
            "\t\tself.writable = \"x\" in file.mode or \"r\" not in file.mode",
            "\t\tself.write = self.buffer.write if self.writable else None",
            "\tdef read(self):",
            "\t\twhile True:",
            "\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "\t\t\tif not b:",
            "\t\t\t\tbreak",
            "\t\t\tptr = self.buffer.tell()",
            "\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "\t\tself.newlines = 0",
            "\t\treturn self.buffer.read()",
            "\tdef readline(self):",
            "\t\twhile self.newlines == 0:",
            "\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "\t\t\tself.newlines = b.count(b\"\\n\") + (not b)",
            "\t\t\tptr = self.buffer.tell()",
            "\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "\t\tself.newlines -= 1",
            "\t\treturn self.buffer.readline()",
            "\tdef flush(self):",
            "\t\tif self.writable:",
            "\t\t\tos.write(self._fd, self.buffer.getvalue())",
            "\t\t\tself.buffer.truncate(0), self.buffer.seek(0)",
            "class IOWrapper(IOBase):",
            "\tdef __init__(self, file):",
            "\t\tself.buffer = FastIO(file)",
            "\t\tself.flush = self.buffer.flush",
            "\t\tself.writable = self.buffer.writable",
            "\t\tself.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
            "\t\tself.read = lambda: self.buffer.read().decode(\"ascii\")",
            "\t\tself.readline = lambda: self.buffer.readline().decode(\"ascii\")",
            "sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
            "",
            "# functions #",
            "# MOD = 998244353",
            "MOD = 10**9 + 7",
            "RANDOM = random.randrange(1,2**62)",
            "def gcd(a,b):",
            "\twhile b:",
            "\t\ta,b = b,a%b",
            "\treturn a",
            "def lcm(a,b):",
            "\treturn a//gcd(a,b)*b",
            "def w(x):",
            "\treturn x ^ RANDOM",
            "II = lambda : int(sys.stdin.readline().strip())",
            "LII = lambda : list(map(int, sys.stdin.readline().split()))",
            "MI = lambda x : x(map(int, sys.stdin.readline().split()))",
            "SI = lambda : sys.stdin.readline().strip()",
            "SLI = lambda : list(map(lambda x:ord(x)-97,sys.stdin.readline().strip()))",
            "LII_1 = lambda : list(map(lambda x:int(x)-1, sys.stdin.readline().split()))",
            "LII_C = lambda x : list(map(x, sys.stdin.readline().split()))",
            "MATI = lambda x : [list(map(int, sys.stdin.readline().split())) for _ in range(x)]",
            "##",
            "",
            "#String hashing: shclass, fenwick sortedlist: fsortl, Number: numtheory/numrare, SparseTable: SparseTable",
            "#Bucket Sorted list: bsortl, Segment Tree(lp,selfop): SegmentTree, bootstrap: bootstrap, Trie: tries",
            "#binary indexed tree: BIT, Segment Tree(point updates): SegmentPoint, Convex Hull: hull, BitArray: bitarray",
            "#Combinatorics: pnc, Diophantine Equations: dpheq, DSU: DSU, Geometry: Geometry, FFT: fft, XOR_dict: xdict",
            "#Persistent Segment Tree: perseg, Binary Trie: b_trie, HLD: hld, String funcs: sf, Segment Tree(lp): SegmentOther",
            "#Graph1(dnc,bl): graphadv, Graph2(khn,sat): 2sat, Graph3(fltn,bprt): graphflatten, Graph4(ep,tp,fw,bmf): graphoth",
            "#Graph5(djik,bfs,dfs): graph, Graph6(dfsin): dfsin, utils: utils, Persistent DSU: perdsu, Merge Sort Tree: sorttree",
            "#2-D BIT: 2DBIT, MonoDeque: mono, matrix: nummat, SuffixAutomaton: sautomaton, linalg: linalg, SquareRtDecomp: sqrt",
            "#Grapth7(bridges): graph_dmgt, FWHT(^,|,&): fwht, Graph8(centr_decom): graph_decom, DpOptimize(knth,dnc): dpopt",
            "2D-SegmentTree: seg2d, Rollback/Par DSU: rbdsu",
            "#Template : https://github.com/OmAmar106/Template-for-Competetive-Programming",
            "#if os.environ.get('LOCAL'):sys.stdin = open(r'input.txt', 'r');sys.stdout = sys.stderr = open(r'output.txt','w')",
            "#if os.environ.get('LOCAL'):import hashlib;print('Hash Value :',hashlib.md5(open(__file__, 'rb').read()).hexdigest());",
            "",
            "def solve():",
            "\tn = II()",
            "\tL = LII()",
            "\t#L1 = LII()",
            "\t#st = SI()",
            "solve()"
	    ],  
		"description": "atcoder/cses template"
	},
    "detcp": {
        "prefix": "detcp",
        "body": [
            "import sys,math,cmath,random,os,time,psutil,hashlib",
            "from heapq import heappush,heappop",
            "from bisect import bisect_right,bisect_left",
            "from collections import Counter,deque,defaultdict",
            "from itertools import permutations,combinations",
            "from io import BytesIO, IOBase",
            "from decimal import Decimal,getcontext",
            "",
            "process = psutil.Process(os.getpid())",
            "BUFSIZE = 8192",
            "class FastIO(IOBase):",
            "\tnewlines = 0",
            "\tdef __init__(self, file):",
            "\t\tself._file = file",
            "\t\tself._fd = file.fileno()",
            "\t\tself.buffer = BytesIO()",
            "\t\tself.writable = \"x\" in file.mode or \"r\" not in file.mode",
            "\t\tself.write = self.buffer.write if self.writable else None",
            "\tdef read(self):",
            "\t\twhile True:",
            "\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "\t\t\tif not b:",
            "\t\t\t\tbreak",
            "\t\t\tptr = self.buffer.tell()",
            "\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "\t\tself.newlines = 0",
            "\t\treturn self.buffer.read()",
            "\tdef readline(self):",
            "\t\twhile self.newlines == 0:",
            "\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "\t\t\tself.newlines = b.count(b\"\\n\") + (not b)",
            "\t\t\tptr = self.buffer.tell()",
            "\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "\t\tself.newlines -= 1",
            "\t\treturn self.buffer.readline()",
            "\tdef flush(self):",
            "\t\tif self.writable:",
            "\t\t\tos.write(self._fd, self.buffer.getvalue())",
            "\t\t\tself.buffer.truncate(0), self.buffer.seek(0)",
            "class IOWrapper(IOBase):",
            "\tdef __init__(self, file):",
            "\t\tself.buffer = FastIO(file)",
            "\t\tself.flush = self.buffer.flush",
            "\t\tself.writable = self.buffer.writable",
            "\t\tself.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
            "\t\tself.read = lambda: self.buffer.read().decode(\"ascii\")",
            "\t\tself.readline = lambda: self.buffer.readline().decode(\"ascii\")",
            "sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
            "",
            "# functions #",
            "# MOD = 998244353",
            "MOD = 10**9 + 7",
            "RANDOM = random.randrange(1,2**62)",
            "def gcd(a,b):",
            "\twhile b:",
            "\t\ta,b = b,a%b",
            "\treturn a",
            "def lcm(a,b):",
            "\treturn a//gcd(a,b)*b",
            "",
            "II = lambda : int(sys.stdin.readline().strip())",
            "LII = lambda : list(map(int, sys.stdin.readline().split()))",
            "MI = lambda x : x(map(int, sys.stdin.readline().split()))",
            "SI = lambda : sys.stdin.readline().strip()",
            "SLI = lambda : list(map(lambda x:ord(x)-97,sys.stdin.readline().strip()))",
            "LII_1 = lambda : list(map(lambda x:int(x)-1, sys.stdin.readline().split()))",
            "LII_C = lambda x : list(map(x, sys.stdin.readline().split()))",
            "MATI = lambda x : [list(map(int, sys.stdin.readline().split())) for _ in range(x)]",
            "",
            "base = os.path.dirname(os.path.abspath(__file__))",
            "sys.stdin  = open(os.path.join(base, \"input.txt\"), \"r\")",
            "sys.stdout = open(os.path.join(base, \"output.txt\"), \"w\")",
            "sys.stderr = open(os.path.join(base, \"error.txt\"), \"w\")",
            "",
            "start = time.time()",
            "",
            "def solve():",
            "",
            "\treturn",
            "",
            "solve()",
            "",
            "print(\"\\n\\n\\n########## Stats ##########\")",
            "print(f\"Time Taken : {time.time()-start:.2f} s\")",
            "mem = process.memory_info().rss / 1e6",
            "print(f\"Memory Used : {mem:.2f} MB\")",
            "print('Hash Value : ',end='')",
            "print(hashlib.md5(open(__file__, 'rb').read()).hexdigest())"
        ],
        "description": "Template for details of runtime"
    },
    "hull": {
        "prefix": "hull",
        "body": [
            "class ConvexHull:",
            "\tdef __init__(self, n=100000):",
            "\t\t# put n equal to max value of ai , bi , you may need to do coordinate compression in case it is upto 10**9",
            "\t\t# works for value which are not increasing as well",
            "\t\tself.n = n",
            "\t\tself.seg = [Line(0, float('inf'))] * (4 * n)",
            "\t\tself.lo = [0] * (4 * n)",
            "\t\tself.hi = [0] * (4 * n)",
            "\t\tself.build(1,1,n)",
            "\tdef build(self, i, l, r):",
            "\t\tstack = [(i, l, r)]",
            "\t\twhile stack:",
            "\t\t\tidx, left, right = stack.pop()",
            "\t\t\tself.lo[idx] = left",
            "\t\t\tself.hi[idx] = right",
            "\t\t\tself.seg[idx] = Line(0, float('inf'))",
            "\t\t\tif left == right:",
            "\t\t\t\tcontinue",
            "\t\t\tmid = (left + right) // 2",
            "\t\t\tstack.append((2 * idx + 1, mid + 1, right))",
            "\t\t\tstack.append((2 * idx, left, mid))",
            "\tdef insert(self,L):",
            "\t\tpos = 1",
            "\t\twhile True:",
            "\t\t\tl, r = self.lo[pos], self.hi[pos]",
            "\t\t\tif l == r:",
            "\t\t\t\tif L(l) < self.seg[pos](l):",
            "\t\t\t\t\tself.seg[pos] = L",
            "\t\t\t\tbreak",
            "\t\t\tm = (l + r) // 2",
            "\t\t\tif self.seg[pos].m < L.m:",
            "\t\t\t\tself.seg[pos], L = L, self.seg[pos]",
            "\t\t\tif self.seg[pos](m) > L(m):",
            "\t\t\t\tself.seg[pos], L = L, self.seg[pos]",
            "\t\t\t\tpos = 2*pos",
            "\t\t\telse:",
            "\t\t\t\tpos = 2*pos+1",
            "\tdef query(self,x):",
            "\t\ti = 1",
            "\t\tres = self.seg[i](x)",
            "\t\tpos = i",
            "\t\twhile True:",
            "\t\t\tl, r = self.lo[pos], self.hi[pos]",
            "\t\t\tif l == r:",
            "\t\t\t\treturn min(res, self.seg[pos](x))",
            "\t\t\tm = (l + r) // 2",
            "\t\t\tif x < m:",
            "\t\t\t\tres = min(res, self.seg[pos](x))",
            "\t\t\t\tpos = 2 * pos",
            "\t\t\telse:",
            "\t\t\t\tres = min(res, self.seg[pos](x))",
            "\t\t\t\tpos = (2 * pos + 1)",
            "",
            "def f(line, x):",
            "\treturn line[0] * x + line[1]",
            "class LiChao:",
            "\tdef __init__(self, lo=0, hi=10**9):",
            "\t\tself.lo = lo",
            "\t\tself.hi = hi",
            "\t\tself.m = (lo + hi) // 2",
            "\t\tself.line = None",
            "\t\tself.left = None",
            "\t\tself.right = None",
            "\tdef add_line(self, new_line):",
            "\t\tl, r, m = self.lo, self.hi, self.m",
            "\t\tif self.line is None:",
            "\t\t\tself.line = new_line",
            "\t\t\treturn",
            "\t\tif f(new_line, m) > f(self.line, m):",
            "\t\t\tself.line, new_line = new_line, self.line",
            "\t\tif l == r:",
            "\t\t\treturn",
            "\t\tif f(new_line, l) > f(self.line, l):",
            "\t\t\tif self.left is None:",
            "\t\t\t\tself.left = LiChao(l, m)",
            "\t\t\tself.left.add_line(new_line)",
            "\t\telif f(new_line, r) > f(self.line, r):",
            "\t\t\tif self.right is None:",
            "\t\t\t\tself.right = LiChao(m + 1, r)",
            "\t\t\tself.right.add_line(new_line)",
            "\tdef query(self, x):",
            "\t\tres = f(self.line, x) if self.line is not None else -10**18",
            "\t\tif self.lo == self.hi:",
            "\t\t\treturn res",
            "\t\tif x <= self.m and self.left is not None:",
            "\t\t\tres = max(res, self.left.query(x))",
            "\t\telif x > self.m and self.right is not None:",
            "\t\t\tres = max(res, self.right.query(x))",
            "\t\treturn res",
            "",
            "class Line:",
            "\tdef __init__(self, m, b, c=0):",
            "\t\t# c is an identifier for the line",
            "\t\tself.m = m;self.b = b;self.c = c",
            "\tdef __call__(self, x):",
            "\t\treturn self.m * x + self.b",
            "class CHT:",
            "\tdef __init__(self):",
            "\t\tself.dq = []",
            "\t\tself.fptr = 0",
            "\tdef clear(self):",
            "\t\tself.dq = [Line(0, 0, 0)]",
            "\t\tself.fptr = 0",
            "\tdef pop_back(self, L, L1, L2):",
            "\t\tv1 = (L.b - L2.b) * (L2.m - L1.m)",
            "\t\tv2 = (L2.m - L.m) * (L1.b - L2.b)",
            "\t\treturn (L.c > L1.c if v1 == v2 else v1 < v2)",
            "\tdef pop_front(self, L1, L2, x):",
            "\t\tv1 = L1(x)",
            "\t\tv2 = L2(x)",
            "\t\treturn (L1.c < L2.c if v1 == v2 else v1 > v2)",
            "\tdef insert(self, L):",
            "\t\twhile len(self.dq) - self.fptr >= 2 and self.pop_back(L, self.dq[-1], self.dq[-2]):",
            "\t\t\tself.dq.pop()",
            "\t\tself.dq.append(L)",
            "\tdef query(self, x):",
            "\t\twhile len(self.dq) - self.fptr >= 2 and self.pop_front(self.dq[self.fptr], self.dq[self.fptr + 1], x):",
            "\t\t\tself.fptr += 1",
            "\t\tline = self.dq[self.fptr]",
            "\t\treturn line(x),line.c"
        ],
        "description": "hull implementation"
    },
    "pnc": {
        "prefix": "pnc",
        "body": [
            "class Factorial:",
            "\tdef __init__(self, N, mod):",
            "\t\tN += 1",
            "\t\tself.mod = mod",
            "\t\tself.f = [1 for _ in range(N)]",
            "\t\tself.g = [1 for _ in range(N)]",
            "\t\tfor i in range(1, N):",
            "\t\t\tself.f[i] = self.f[i - 1] * i % self.mod",
            "\t\tself.g[-1] = pow(self.f[-1], mod - 2, mod)",
            "\t\tfor i in range(N - 2, -1, -1):",
            "\t\t\tself.g[i] = self.g[i + 1] * (i + 1) % self.mod",
            "\tdef derangements(self,n):",
            "\t\t# Number of permutations of n objects where no object appears in its original position",
            "\t\treturn int(self.fac(n)/math.e+0.5)",
            "\tdef stirling_2(self,n,k):",
            "\t\t# Number of ways to partition n elements into k non-empty subsets",
            "\t\treturn sum(((-1)**(k - j)) * math.comb(k, j) * (j**n) for j in range(k + 1)) // math.factorial(k)",
            "\tdef stirling_2_mod(self,n,k):",
            "\t\treturn (sum(((-1)**(k - j))*self.combi(k, j)*pow(j,n,self.mod) for j in range(k + 1)) * self.fac_inv(k))%self.mod",
            "\tdef partition(self,n,k):",
            "\t\t# Ways to partition n into k or fewer parts of size 1 or greater",
            "\t\t# add dp[(n,k)] and memoize it if using it.",
            "\t\tif n<0 or (k<1 and n>0):return 0",
            "\t\tif n==0:return 1",
            "\t\treturn 1 if n==1 else self.partition(n,k-1)+self.partition(n-k,k)",
            "\tdef catalan(self, n):",
            "\t\treturn (self.combi(2 * n, n) - self.combi(2 * n, n - 1)) % self.mod",
            "\tdef fac(self, n):",
            "\t\treturn self.f[n]",
            "\tdef fac_inv(self, n):",
            "\t\treturn self.g[n]",
            "\tdef combi(self, n, m):",
            "\t\tif m == 0: return 1",
            "\t\tif n < m or m < 0 or n < 0: return 0",
            "\t\treturn self.f[n] * self.g[m] % self.mod * self.g[n - m] % self.mod",
            "\tdef permu(self, n, m):",
            "\t\tif n < m or m < 0 or n < 0: return 0",
            "\t\treturn self.f[n] * self.g[n - m] % self.mod",
            "\tdef inv(self, n):",
            "\t\treturn self.f[n-1] * self.g[n] % self.mod"
        ],
        "description": "Class for efficient computation of factorials, combinations, permutations, Catalan numbers, and modular inverses with precomputation."
    },
    "numtheory": {
        "prefix": "numtheory",
        "body": [
            "def miller_is_prime(n):",
            "\t\"\"\"",
            "\t\tMiller-Rabin test - O(7 * log2n)",
            "\t\tHas 100% success rate for numbers less than 3e+9",
            "\t\tuse it in case of TC problem",
            "\t\"\"\"",
            "\tif n < 5 or n & 1 == 0 or n % 3 == 0:",
            "\t\treturn 2 <= n <= 3",
            "\ts = ((n - 1) & (1 - n)).bit_length() - 1",
            "\td = n >> s",
            "\tfor a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:",
            "\t\tp = pow(a, d, n)",
            "\t\tif p == 1 or p == n - 1 or a % n == 0:",
            "\t\t\tcontinue",
            "\t\tfor _ in range(s):",
            "\t\t\tp = (p * p) % n",
            "\t\t\tif p == n - 1:",
            "\t\t\t\tbreak",
            "\t\telse:",
            "\t\t\treturn False",
            "\treturn True",
            "",
            "def is_prime(n):",
            "\tif n <= 1:",
            "\t\treturn False",
            "\tif n <= 3:",
            "\t\treturn True",
            "\tif n % 2 == 0 or n % 3 == 0:",
            "\t\treturn False",
            "\ti = 5",
            "\twhile i * i <= n:",
            "\t\tif n % i == 0 or n % (i + 2) == 0:",
            "\t\t\treturn False",
            "\t\ti += 6",
            "\treturn True",
            "",
            "def sieve(n):",
            "\tprimes = []",
            "\tisp = [1] * (n+1)",
            "\tisp[0] = isp[1] = 0",
            "\tfor i in range(2,n+1):",
            "\t\tif isp[i]:",
            "\t\t\tprimes.append(i)",
            "\t\t\tfor j in range(i*i,n+1,i):",
            "\t\t\t\tisp[j] = 0",
            "\treturn primes",
            "",
            "def all_fact(n):",
            "\t\"\"\"",
            "\treturns a sorted list of all distinct factors of n in root n",
            "\t\"\"\"",
            "\tsmall, large = [], []",
            "\tfor i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):",
            "\t\tif not n % i:",
            "\t\t\tsmall.append(i)",
            "\t\t\tlarge.append(n // i)",
            "\tif small[-1] == large[-1]:",
            "\t\tlarge.pop()",
            "\tlarge.reverse()",
            "\tsmall.extend(large)",
            "\treturn small",
            "",
            "calc = False",
            "if calc:",
            "\tdef sieve_unique(N):",
            "\t\tmini = [i for i in range(N)]",
            "\t\tfor i in range(2,N):",
            "\t\t\tif mini[i]==i:",
            "\t\t\t\tfor j in range(2*i,N,i):",
            "\t\t\t\t\tmini[j] = i",
            "\t\treturn mini",
            "",
            "\tMAX_N = 10**6+1",
            "\tLmini = sieve_unique(MAX_N)",
            "",
            "\tdef prime_factors(k,typ=0):",
            "\t\t\"\"\"",
            "\t\t\tWhen the numbers are large this is the best method to get",
            "\t\t\tunique prime factors, precompute n log log n , then each query is log n",
            "\t\t\"\"\"",
            "\t\tif typ==0:",
            "\t\t\tans = Counter()",
            "\t\telif typ==1:",
            "\t\t\tans = set()",
            "\t\telse:",
            "\t\t\tans = []",
            "\t\twhile k!=1:",
            "\t\t\tif typ==0:",
            "\t\t\t\tans[Lmini[k]] += 1",
            "\t\t\telif typ==1:",
            "\t\t\t\tans.add(Lmini[k])",
            "\t\t\telse:",
            "\t\t\t\tans.append(Lmini[k])",
            "\t\t\tk //= Lmini[k]",
            "\t\treturn ans",
            "",
            "\tdef all_factors(x):",
            "\t\t# returns all factors of x in log x + d",
            "\t\tL = list(prime_factors(x).items())",
            "\t\tst = [1]",
            "\t\tfor i in range(len(L)):",
            "\t\t\tfor j in range(len(st)-1,-1,-1):",
            "\t\t\t\tk = L[i][0]",
            "\t\t\t\tfor l in range(L[i][1]):",
            "\t\t\t\t\tst.append(st[j]*k)",
            "\t\t\t\t\tk *= L[i][0]",
            "\t\treturn st"
        ],
        "description": "numtheory implementation"
    },
    "numrare": {
        "prefix": "numrare",
        "body": [
            "def memodict(f):",
            "\tclass memodict(dict):",
            "\t\tdef __missing__(self, key):",
            "\t\t\tret = self[key] = f(key)",
            "\t\t\treturn ret",
            "\treturn memodict().__getitem__",
            "",
            "def pollard_rho(n):",
            "\t# returns a random factor of n",
            "\tif n&1==0:return 2",
            "\tif n%3==0:return 3",
            "\ts = ((n-1)&(1-n)).bit_length() - 1",
            "\td = n>>s",
            "\tfor a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:",
            "\t\tp = pow(a, d, n)",
            "\t\tif p == 1 or p == n - 1 or a % n == 0:continue",
            "\t\tfor _ in range(s):",
            "\t\t\tprev = p",
            "\t\t\tp = (p * p) % n",
            "\t\t\tif p == 1:return gcd(prev - 1, n)",
            "\t\t\tif p == n - 1:break",
            "\t\telse:",
            "\t\t\tfor i in range(2, n):",
            "\t\t\t\tx, y = i, (i * i + 1) % n",
            "\t\t\t\tf = gcd(abs(x - y), n)",
            "\t\t\t\twhile f == 1:",
            "\t\t\t\t\tx, y = (x * x + 1) % n, (y * y + 1) % n",
            "\t\t\t\t\ty = (y * y + 1) % n",
            "\t\t\t\t\tf = gcd(abs(x - y), n)",
            "\t\t\t\tif f != n:return f",
            "\treturn n",
            "",
            "@memodict",
            "def prime_factors_large(n):",
            "\t# returns prime factor in n^(1/4) but is probablistic",
            "\tif n <= 1:return Counter()",
            "\tf = pollard_rho(n)",
            "\treturn Counter([n]) if f == n else prime_factors_large(f) + prime_factors_large(n // f)",
            "",
            "def discrete_log(a, b, mod):",
            "\t# returns smalest x such that pow(a,x,mod) = b",
            "\tn = int(mod**0.5) + 1",
            "\ttiny_step, e = {}, 1",
            "\tfor j in range(1, n + 1):",
            "\t\te = e * a % mod",
            "\t\tif e == b:",
            "\t\t\treturn j",
            "\t\ttiny_step[b * e % mod] = j",
            "\tfactor = e",
            "\tfor i in range(2, n + 2):",
            "\t\te = e * factor % mod",
            "\t\tif e in tiny_step:",
            "\t\t\tj = tiny_step[e]",
            "\t\t\treturn n * i - j if pow(a, n * i - j, mod) == b else None",
            "\treturn None",
            "",
            "def extended_gcd(a, b):",
            "\t# returns gcd(a, b), s, r s.t. a * s + b * r == gcd(a, b)",
            "\ts, old_s = 0, 1",
            "\tr, old_r = b, a",
            "\twhile r:",
            "\t\tq = old_r // r",
            "\t\told_r, r = r, old_r - q * r",
            "\t\told_s, s = s, old_s - q * s",
            "\treturn old_r, old_s, (old_r - old_s * a) // b if b else 0",
            "",
            "def composite_crt(b, m):",
            "\t# returns x s.t. x = b[i] (mod m[i]) for all i",
            "\tx, m_prod = 0, 1",
            "\tfor bi, mi in zip(b, m):",
            "\t\tg, s, _ = extended_gcd(m_prod, mi)",
            "\t\tif ((bi - x) % mi) % g:",
            "\t\t\treturn None",
            "\t\tx += m_prod * (s * ((bi - x) % mi) // g)",
            "\t\tm_prod = (m_prod * mi) // gcd(m_prod, mi)",
            "\treturn x % m_prod",
            "",
            "def phi(n):",
            "\tph = [i if i & 1 else i // 2 for i in range(n + 1)]",
            "\tfor i in range(3,n+1,2):",
            "\t\tif ph[i]==i:",
            "\t\t\tfor j in range(i,n+1,i):",
            "\t\t\t\tph[j] = (ph[j]//i)*(i-1)",
            "\treturn ph"
        ],
        "description": "numrare implementation"
    },
    "nummat": {
        "prefix": "nummat",
        "body": [
            "class Matrix:",
            "\tMOD = 10**9+7",
            "\t@staticmethod",
            "\tdef transpose(mat):",
            "\t\treturn [list(c) for c in zip(*mat)]",
            "\tdef __init__(self,M):",
            "\t\tself.M=M",
            "\tdef __matmul__(self,o):",
            "\t\tL,B=self.M,o.M",
            "\t\tr=len(L); c=len(B[0])",
            "\t\treturn Matrix([[sum(L[i][k]*B[k][j] for k in range(len(B)))%self.MOD for j in range(c)] for i in range(r)])",
            "\tdef __pow__(self,p):",
            "\t\tM=self; n=len(M.M)",
            "\t\tR=Matrix([[i==j for j in range(n)] for i in range(n)])",
            "\t\twhile p:",
            "\t\t\tR = R@M if p&1 else R",
            "\t\t\tM = M@M",
            "\t\t\tp//=2",
            "\t\treturn R",
            "\t@staticmethod",
            "\tdef gauss(A,mod=10**9+7):",
            "\t\tm,n=len(A),len(A[0])-1; r=0; L=[-1]*n",
            "\t\tfor c in range(n):",
            "\t\t\tfor i in range(r,m):",
            "\t\t\t\tif A[i][c]: A[r],A[i]=A[i],A[r]",
            "\t\t\t\tbreak",
            "\t\t\telse:",
            "\t\t\t\tcontinue",
            "\t\t\tk=pow(A[r][c],-1,mod)",
            "\t\t\tfor j in range(c,n+1):",
            "\t\t\t\tA[r][j]=A[r][j]*k%mod",
            "\t\t\tfor i in range(m):",
            "\t\t\t\tif i!=r and A[i][c]:",
            "\t\t\t\t\tf=A[i][c]",
            "\t\t\t\t\tfor j in range(c,n+1):",
            "\t\t\t\t\t\tA[i][j]=(A[i][j]-f*A[r][j])%mod",
            "\t\t\tL[c]=r",
            "\t\t\tr+=1",
            "\t\tif any(A[i][n] for i in range(r,m)):",
            "\t\t\treturn None",
            "\t\treturn [A[L[i]][n] if L[i]!=-1 else 0 for i in range(n)]",
            "\tdef __str__(self):",
            "\t\treturn '\\n'.join(' '.join(map(str,row)) for row in self.M)",
            "\tdef __repr__(self):",
            "\t\treturn f\"Matrix({self.M})\"",
            "\tdef __iter__(self):",
            "\t\treturn iter(self.M)"
        ],
        "description": "nummat implementation"
    },
    "Sorted List": {
        "prefix": "bsortl",
        "body": [
            "from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
            "T = TypeVar('T')",
            "class SortedList(Generic[T]):",
            "\tBUCKET_RATIO = 16",
            "\tSPLIT_RATIO = 24",
            "\tdef __init__(self, a: Iterable[T] = []) -> None:",
            "\t\ta = list(a)",
            "\t\tn = self.size = len(a)",
            "\t\tif any(a[i] > a[i + 1] for i in range(n - 1)):",
            "\t\t\ta.sort()",
            "\t\tnum_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
            "\t\tself.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
            "\tdef __iter__(self) -> Iterator[T]:",
            "\t\tfor i in self.a:",
            "\t\t\tfor j in i: yield j",
            "\tdef __reversed__(self) -> Iterator[T]:",
            "\t\tfor i in reversed(self.a):",
            "\t\t\tfor j in reversed(i): yield j",
            "\tdef __eq__(self, other) -> bool:return list(self) == list(other)",
            "\tdef __len__(self) -> int:return self.size",
            "\tdef __repr__(self) -> str:return \"SortedMultiset\" + str(self.a)",
            "\tdef __str__(self) -> str:",
            "\t\ts = str(list(self))",
            "\t\treturn \"{\" + s[1 : len(s) - 1] + \"}\"",
            "\tdef _position(self, x: T) -> Tuple[List[T], int, int]:",
            "\t\tfor i, a in enumerate(self.a):",
            "\t\t\tif x <= a[-1]: break",
            "\t\treturn (a, i, bisect_left(a, x))",
            "\tdef __contains__(self, x: T) -> bool:",
            "\t\tif self.size == 0: return False",
            "\t\ta, _, i = self._position(x)",
            "\t\treturn i != len(a) and a[i] == x",
            "\tdef count(self, x: T) -> int:return self.index_right(x) - self.index(x)",
            "\tdef add(self,x):return self.insert(x)",
            "\tdef insert(self, x: T) -> None:",
            "\t\tif self.size == 0:",
            "\t\t\tself.a = [[x]]",
            "\t\t\tself.size = 1",
            "\t\t\treturn",
            "\t\ta, b, i = self._position(x)",
            "\t\ta.insert(i, x)",
            "\t\tself.size += 1",
            "\t\tif len(a) > len(self.a) * self.SPLIT_RATIO:",
            "\t\t\tmid = len(a) >> 1",
            "\t\t\tself.a[b:b+1] = [a[:mid], a[mid:]]",
            "\tdef _pop(self, a: List[T], b: int, i: int) -> T:",
            "\t\tans = a.pop(i)",
            "\t\tself.size -= 1",
            "\t\tif not a: del self.a[b]",
            "\t\treturn ans",
            "\tdef remove(self, x: T) -> bool:",
            "\t\tif self.size == 0: return False",
            "\t\ta, b, i = self._position(x)",
            "\t\tif i == len(a) or a[i] != x: return False",
            "\t\tself._pop(a, b, i)",
            "\t\treturn True",
            "\tdef lt(self, x: T) -> Optional[T]:",
            "\t\tfor a in reversed(self.a):",
            "\t\t\tif a[0] < x:",
            "\t\t\t\treturn a[bisect_left(a, x) - 1]",
            "\tdef le(self, x: T) -> Optional[T]:",
            "\t\tfor a in reversed(self.a):",
            "\t\t\tif a[0] <= x:",
            "\t\t\t\treturn a[bisect_right(a, x) - 1]",
            "\tdef gt(self, x: T) -> Optional[T]:",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] > x:",
            "\t\t\t\treturn a[bisect_right(a, x)]",
            "\tdef ge(self, x: T) -> Optional[T]:",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] >= x:",
            "\t\t\t\treturn a[bisect_left(a, x)]",
            "\tdef __getitem__(self, i: int) -> T:",
            "\t\tif i < 0:",
            "\t\t\tfor a in reversed(self.a):",
            "\t\t\t\ti += len(a)",
            "\t\t\t\tif i >= 0: return a[i]",
            "\t\telse:",
            "\t\t\tfor a in self.a:",
            "\t\t\t\tif i < len(a): return a[i]",
            "\t\t\t\ti -= len(a)",
            "\t\traise IndexError",
            "\tdef pop(self, i: int = -1) -> T:",
            "\t\tif i < 0:",
            "\t\t\tfor b, a in enumerate(reversed(self.a)):",
            "\t\t\t\ti += len(a)",
            "\t\t\t\tif i >= 0: return self._pop(a, ~b, i)",
            "\t\telse:",
            "\t\t\tfor b, a in enumerate(self.a):",
            "\t\t\t\tif i < len(a): return self._pop(a, b, i)",
            "\t\t\t\ti -= len(a)",
            "\t\traise IndexError",
            "\tdef bisect_left(self,x):return self.index(x)",
            "\tdef index(self, x: T) -> int:",
            "\t\tans = 0",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] >= x:",
            "\t\t\t\treturn ans + bisect_left(a, x)",
            "\t\t\tans += len(a)",
            "\t\treturn ans",
            "\tdef bisect_right(self,x):return self.index_right(x)",
            "\tdef index_right(self, x: T) -> int:",
            "\t\tans = 0",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] > x:",
            "\t\t\t\treturn ans + bisect_right(a, x)",
            "\t\t\tans += len(a)",
            "\t\treturn ans",
            "\tdef find_closest(self, k: T) -> Optional[T]:",
            "\t\tif self.size == 0:return None",
            "\t\tltk = self.le(k);gtk = self.ge(k)",
            "\t\tif ltk is None:return gtk",
            "\t\tif gtk is None:return ltk",
            "\t\treturn ltk if abs(k-ltk)<=abs(k-gtk) else gtk"
        ],
        "description": "Bucket Sorted List implementation"
    },
    "SegmentTree": {
        "prefix": "segmenttree",
        "body": [
            "class SegmentTree:",
            "\tdef __init__(self, data, default=0, func=max):",
            "\t\t# don't forget to change func here",
            "\t\t# default is the value given to it byy default",
            "\t\tself._default = default",
            "\t\tself._func = func",
            "",
            "\t\tself._len = len(data)",
            "\t\tself._size = _size = 1 << (self._len - 1).bit_length()",
            "\t\tself._lazy = [0] * (2 * _size)",
            "",
            "\t\tself.data = [default] * (2 * _size)",
            "\t\tself.data[_size:_size + self._len] = data",
            "\t\tfor i in reversed(range(_size)):",
            "\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])",
            "\tdef __getitem__(self, k):",
            "\t\tif isinstance(k, slice):",
            "\t\t\tl = 0 if k.start is None else k.start",
            "\t\t\tr = self._len if k.stop is None else k.stop",
            "\t\t\treturn self.query(l, r)",
            "\t\treturn self.query(k, k+1)",
            "\tdef __setitem__(self, k, v):",
            "\t\tif isinstance(k, slice):",
            "\t\t\tl = 0 if k.start is None else k.start",
            "\t\t\tr = self._len if k.stop is None else k.stop",
            "\t\t\tself.add(l, r, v)",
            "\t\telse:",
            "\t\t\tcur = self.query(k, k+1)",
            "\t\t\tself.add(k, k+1, v-cur)",
            "\tdef __len__(self):",
            "\t\treturn self._len",
            "\tdef _push(self, idx):",
            "\t\tq, self._lazy[idx] = self._lazy[idx], 0",
            "\t\tself._lazy[2 * idx] += q",
            "\t\tself._lazy[2 * idx + 1] += q",
            "\t\tself.data[2 * idx] += q",
            "\t\tself.data[2 * idx + 1] += q",
            "\tdef _update(self, idx):",
            "\t\tfor i in reversed(range(1, idx.bit_length())):",
            "\t\t\tself._push(idx >> i)",
            "\tdef _build(self, idx):",
            "\t\tidx >>= 1",
            "\t\twhile idx:",
            "\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1]) + self._lazy[idx]",
            "\t\t\tidx >>= 1",
            "\tdef add(self, start, stop, value):",
            "\t\t# lazily add value to [start, stop)",
            "\t\tstart = start_copy = start + self._size",
            "\t\tstop = stop_copy = stop + self._size",
            "\t\twhile start < stop:",
            "\t\t\tif start & 1:",
            "\t\t\t\tself._lazy[start] += value",
            "\t\t\t\tself.data[start] += value",
            "\t\t\t\tstart += 1",
            "\t\t\tif stop & 1:",
            "\t\t\t\tstop -= 1",
            "\t\t\t\tself._lazy[stop] += value",
            "\t\t\t\tself.data[stop] += value",
            "\t\t\tstart >>= 1",
            "\t\t\tstop >>= 1",
            "\t\tself._build(start_copy)",
            "\t\tself._build(stop_copy - 1)",
            "\tdef query(self, start, stop, default=-float('inf')):",
            "\t\t# func of data[start, stop)",
            "\t\t# don't forget to update the default",
            "\t\tstart += self._size",
            "\t\tstop += self._size",
            "\t\tself._update(start)",
            "\t\tself._update(stop - 1)",
            "\t\tres = default",
            "\t\twhile start < stop:",
            "\t\t\tif start & 1:",
            "\t\t\t\tres = self._func(res, self.data[start])",
            "\t\t\t\tstart += 1",
            "\t\t\tif stop & 1:",
            "\t\t\t\tstop -= 1",
            "\t\t\t\tres = self._func(res, self.data[stop])",
            "\t\t\tstart >>= 1",
            "\t\t\tstop >>= 1",
            "\t\treturn res",
            "\tdef __repr__(self):",
            "\t\treturn f\"LazySegmentTree({[self.query(i,i+1) for i in range(self._len)]})\"",
            "",
            "class Node:",
            "\tdef __init__(self,val=0):",
            "\t\tself.val=val",
            "\tdef merge(a,b):",
            "\t\treturn Node(max(a.val,b.val))",
            "\tdef add(self,x):",
            "\t\tself.val+=x",
            "class SegmentTree:",
            "\tdef __init__(self,a):",
            "\t\tself.n=len(a)",
            "\t\tself.t=[Node() for _ in range(4*self.n)]",
            "\t\tself.lz=[0]*(4*self.n)",
            "\t\tself._build(1,0,self.n,a)",
            "\tdef _build(self,i,l,r,a):",
            "\t\tif r-l==1:",
            "\t\t\tif l<len(a): self.t[i]=Node(a[l])",
            "\t\t\treturn",
            "\t\tm=(l+r)//2",
            "\t\tself._build(i<<1,l,m,a)",
            "\t\tself._build(i<<1|1,m,r,a)",
            "\t\tself.t[i]=Node.merge(self.t[i<<1],self.t[i<<1|1])",
            "\tdef _push(self,i):",
            "\t\tif self.lz[i]:",
            "\t\t\tfor c in(i<<1,i<<1|1):",
            "\t\t\t\tself.t[c].add(self.lz[i])",
            "\t\t\t\tself.lz[c]+=self.lz[i]",
            "\t\t\tself.lz[i]=0",
            "\tdef add(self,L,R,v,i=1,l=0,r=None):",
            "\t\t# add v to range [L,R)",
            "\t\tif r is None: r=self.n",
            "\t\tif R<=l or r<=L: return",
            "\t\tif L<=l and r<=R:",
            "\t\t\tself.t[i]+=v; self.lz[i]+=v; return",
            "\t\tself._push(i,l,r)",
            "\t\tm=(l+r)//2",
            "\t\tself.add(L,R,v,i<<1,l,m)",
            "\t\tself.add(L,R,v,i<<1|1,m,r)",
            "\t\tself.t[i]=self.f(self.t[i<<1],self.t[i<<1|1])",
            "\tdef query(self,L,R,i=1,l=0,r=None):",
            "\t\t# query function on range [L,R)",
            "\t\tif r is None: r=self.n",
            "\t\tif R<=l or r<=L: return self.d",
            "\t\tif L<=l and r<=R: return self.t[i]",
            "\t\tself._push(i,l,r)",
            "\t\tm=(l+r)//2",
            "\t\treturn self.f(self.query(L,R,i<<1,l,m),self.query(L,R,i<<1|1,m,r))"
        ],
        "description": "SegmentTree implementation"
    },
    "SegmentOther": {
        "prefix": "segmentother",
        "body": [
            "class SegmentTree:",
            "\tclass _RangeProxy:",
            "\t\tdef __init__(self, seg, sl):",
            "\t\t\tself.seg, self.sl = seg, sl",
            "\t\tdef __iadd__(self, v):",
            "\t\t\tself.seg.range_update(self.sl.start, self.sl.stop-1, v, True)",
            "\t\t\treturn self",
            "\t\tdef __repr__(self):",
            "\t\t\treturn str(self.seg.range_query(self.sl.start, self.sl.stop-1))",
            "\tdef __getitem__(self, k):",
            "\t\tif isinstance(k, slice):",
            "\t\t\treturn SegmentTree._RangeProxy(self, k)",
            "\t\treturn self.range_query(k, k)",
            "\tdef __setitem__(self, k, v):",
            "\t\tif isinstance(v, SegmentTree._RangeProxy):",
            "\t\t\treturn",
            "\t\tif isinstance(k, slice):",
            "\t\t\tself.range_update(k.start, k.stop-1, v, False)",
            "\t\telse:",
            "\t\t\tself.range_update(k, k, v, False)",
            "\tdef __init__(self, data, default=0, mode='s',func=lambda x,y:x+y):",
            "\t\tself.func = func",
            "\t\tself.mode = mode",
            "\t\tself._default = default",
            "\t\tself.n = len(data)",
            "\t\tself.size = 1 << (self.n - 1).bit_length()",
            "\t\tself.tree = [default] * (2 * self.size)",
            "\t\tself._size = [0] * (2 * self.size)",
            "\t\tself._size[self.size:] = [1] * self.size",
            "\t\tfor i in range(self.size - 1, 0, -1):",
            "\t\t\tself._size[i] = self._size[i << 1] + self._size[i << 1 | 1]",
            "\t\tself.lazy_add = 0 if self.mode == 's' else 0",
            "\t\tself.lazy_set = None",
            "\t\tself.lazy_add = [0] * self.size",
            "\t\tself.lazy_set = [None] * self.size",
            "\t\tfor i in range(self.n):",
            "\t\t\tself.tree[self.size + i] = data[i]",
            "\t\tfor i in range(self.size - 1, 0, -1):",
            "\t\t\tself.tree[i] = self.func(self.tree[i << 1], self.tree[i << 1 | 1])",
            "\tdef _apply_set(self, pos, value):",
            "\t\tif self.mode == 's':",
            "\t\t\tself.tree[pos] = value * self._size[pos]",
            "\t\telse:",
            "\t\t\tself.tree[pos] = value",
            "\t\tif pos < self.size:",
            "\t\t\tself.lazy_set[pos] = value",
            "\t\t\tself.lazy_add[pos] = 0",
            "\tdef _apply_add(self, pos, value):",
            "\t\tif self.mode == 's':",
            "\t\t\tself.tree[pos] += value * self._size[pos]",
            "\t\telse:",
            "\t\t\tself.tree[pos] += value",
            "\t\tif pos < self.size:",
            "\t\t\tif self.lazy_set[pos] is not None:",
            "\t\t\t\tself.lazy_set[pos] += value",
            "\t\t\telse:",
            "\t\t\t\tself.lazy_add[pos] += value",
            "\tdef _build(self, pos):",
            "\t\twhile pos > 1:",
            "\t\t\tpos >>= 1",
            "\t\t\tself.tree[pos] = self.func(self.tree[pos << 1], self.tree[pos << 1 | 1])",
            "\t\t\tif self.lazy_set[pos] is not None:",
            "\t\t\t\tif self.mode == 's':",
            "\t\t\t\t\tself.tree[pos] = self.lazy_set[pos] * self._size[pos]",
            "\t\t\t\telse:",
            "\t\t\t\t\tself.tree[pos] = self.lazy_set[pos]",
            "\t\t\tif self.lazy_add[pos] != 0:",
            "\t\t\t\tif self.mode == 's':",
            "\t\t\t\t\tself.tree[pos] += self.lazy_add[pos] * self._size[pos]",
            "\t\t\t\telse:",
            "\t\t\t\t\tself.tree[pos] += self.lazy_add[pos]",
            "\tdef _push(self, pos):",
            "\t\tfor shift in range(self.size.bit_length() - 1, 0, -1):",
            "\t\t\ti = pos >> shift",
            "\t\t\tset_val = self.lazy_set[i]",
            "\t\t\tif set_val is not None:",
            "\t\t\t\tself._apply_set(i << 1, set_val)",
            "\t\t\t\tself._apply_set(i << 1 | 1, set_val)",
            "\t\t\t\tself.lazy_set[i] = None",
            "\t\t\tadd_val = self.lazy_add[i]",
            "\t\t\tif add_val != 0:",
            "\t\t\t\tself._apply_add(i << 1, add_val)",
            "\t\t\t\tself._apply_add(i << 1 | 1, add_val)",
            "\t\t\t\tself.lazy_add[i] = 0",
            "\tdef range_update(self, left, right, value,flag=True):",
            "\t\t# Range Update in [L,R] if flag, then add",
            "\t\tif flag:",
            "\t\t\tl = left + self.size",
            "\t\t\tr = right + self.size",
            "\t\t\tl0, r0 = l, r",
            "\t\t\tself._push(l0)",
            "\t\t\tself._push(r0)",
            "\t\t\twhile l <= r:",
            "\t\t\t\tif l & 1: self._apply_add(l, value); l += 1",
            "\t\t\t\tif not r & 1: self._apply_add(r, value); r -= 1",
            "\t\t\t\tl >>= 1; r >>= 1",
            "\t\t\tself._build(l0)",
            "\t\t\tself._build(r0)",
            "\t\telse:",
            "\t\t\tl = left + self.size",
            "\t\t\tr = right + self.size",
            "\t\t\tl0, r0 = l, r",
            "\t\t\tself._push(l0)",
            "\t\t\tself._push(r0)",
            "\t\t\twhile l <= r:",
            "\t\t\t\tif l & 1: self._apply_set(l, value); l += 1",
            "\t\t\t\tif not r & 1: self._apply_set(r, value); r -= 1",
            "\t\t\t\tl >>= 1; r >>= 1",
            "\t\t\tself._build(l0)",
            "\t\t\tself._build(r0)",
            "\tdef range_query(self, left, right):",
            "\t\t# Range Query in [L,R]",
            "\t\tl = left + self.size",
            "\t\tr = right + self.size",
            "\t\tself._push(l)",
            "\t\tself._push(r)",
            "\t\tres = self._default",
            "\t\twhile l <= r:",
            "\t\t\tif l & 1: res = self.func(res, self.tree[l]); l += 1",
            "\t\t\tif not r & 1: res = self.func(res, self.tree[r]); r -= 1",
            "\t\t\tl >>= 1; r >>= 1",
            "\t\treturn res",
            "\tdef __repr__(self):",
            "\t\treturn f\"SegmentTree({[self.range_query(i,i) for i in range(self.n)]})\""
        ],
        "description": "SegmentOther implementation"
    },
	"sortl": {
        "prefix": "fsortl",
        "body": [
            "class FenwickTree:",
            "\tdef __init__(self, x):",
            "\t\tbit = self.bit = list(x)",
            "\t\tsize = self.size = len(bit)",
            "\t\tfor i in range(size):",
            "\t\t\tj = i | (i + 1)",
            "\t\t\tif j < size:",
            "\t\t\t\tbit[j] += bit[i]",
            "\tdef update(self, idx, x):",
            "\t\twhile idx < self.size:",
            "\t\t\tself.bit[idx] += x",
            "\t\t\tidx |= idx + 1",
            "\tdef __call__(self, end):",
            "\t\tx = 0",
            "\t\twhile end:",
            "\t\t\tx += self.bit[end - 1]",
            "\t\t\tend &= end - 1 ",
            "\t\treturn x",
            "\tdef find_kth(self, k):",
            "\t\tidx = -1",
            "\t\tfor d in reversed(range(self.size.bit_length())):",
            "\t\t\tright_idx = idx + (1 << d)",
            "\t\t\tif right_idx < self.size and self.bit[right_idx] <= k:",
            "\t\t\t\tidx = right_idx",
            "\t\t\t\tk -= self.bit[idx]",
            "\t\treturn idx + 1, k",
            "class SortedList:",
            "\tblock_size = 700",
            "\tdef __init__(self, iterable=()):",
            "\t\tself.macro = []",
            "\t\tself.micros = [[]]",
            "\t\tself.micro_size = [0]",
            "\t\tself.fenwick = FenwickTree([0])",
            "\t\tself.size = 0",
            "\t\tfor item in iterable:",
            "\t\t\tself.insert(item)",
            "\tdef insert(self, x):",
            "\t\ti = bisect_left(self.macro, x)",
            "\t\tj = bisect_right(self.micros[i], x)",
            "\t\tself.micros[i].insert(j, x)",
            "\t\tself.size += 1",
            "\t\tself.micro_size[i] += 1",
            "\t\tself.fenwick.update(i, 1)",
            "\t\tif len(self.micros[i]) >= self.block_size:",
            "\t\t\tself.micros[i:i + 1] = self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:]",
            "\t\t\tself.micro_size[i:i + 1] = self.block_size >> 1, self.block_size >> 1",
            "\t\t\tself.fenwick = FenwickTree(self.micro_size)",
            "\t\t\tself.macro.insert(i, self.micros[i + 1][0])",
            "\tdef add(self, x):",
            "\t\tself.insert(x)",
            "\tdef pop(self, k=-1):",
            "\t\ti, j = self._find_kth(k)",
            "\t\tself.size -= 1",
            "\t\tself.micro_size[i] -= 1",
            "\t\tself.fenwick.update(i, -1)",
            "\t\treturn self.micros[i].pop(j)",
            "\tdef remove(self, N: int):",
            "\t\tidx = self.bisect_left(N)",
            "\t\tself.pop(idx)",
            "\tdef __getitem__(self, k):",
            "\t\ti, j = self._find_kth(k)",
            "\t\treturn self.micros[i][j]",
            "\tdef count(self, x):",
            "\t\treturn self.bisect_right(x) - self.bisect_left(x)",
            "\tdef __contains__(self, x):",
            "\t\treturn self.count(x) > 0",
            "\tdef bisect_left(self, x):",
            "\t\ti = bisect_left(self.macro, x)",
            "\t\treturn self.fenwick(i) + bisect_left(self.micros[i], x)",
            "\tdef bisect_right(self, x):",
            "\t\ti = bisect_right(self.macro, x)",
            "\t\treturn self.fenwick(i) + bisect_right(self.micros[i], x)",
            "\tdef _find_kth(self, k):",
            "\t\treturn self.fenwick.find_kth(k + self.size if k < 0 else k)",
            "\tdef __len__(self):",
            "\t\treturn self.size",
            "\tdef __iter__(self):",
            "\t\treturn (x for micro in self.micros for x in micro)",
            "\tdef __repr__(self):",
            "\t\treturn str(list(self))"
        ],
        "description": "sorted list using fenwick tree use for insertion,deletion,traversel in log(n)"
    },
    "bootstrap": {
        "prefix": "bootstrap",
        "body": [
            "from types import GeneratorType",
            "",
            "def bootstrap(f, stack=[]):",
            "\tdef wrappedfunc(*args, **kwargs):",
            "\t\tif stack:",
            "\t\t\treturn f(*args, **kwargs)",
            "\t\telse:",
            "\t\t\tto = f(*args, **kwargs)",
            "\t\t\twhile True:",
            "\t\t\t\tif type(to) is GeneratorType:",
            "\t\t\t\t\tstack.append(to)",
            "\t\t\t\t\tto = next(to)",
            "\t\t\t\telse:",
            "\t\t\t\t\tstack.pop()",
            "\t\t\t\t\tif not stack:",
            "\t\t\t\t\t\tbreak",
            "\t\t\t\t\tto = stack[-1].send(to)",
            "\t\t\treturn to",
            "\treturn wrappedfunc",
            "",
            "# @bootstrap",
            "# put this just on top of recursion function to increase the recursion limit",
            "",
            "# rather than return now use yield and when function being called inside itself, use yield before the function name",
            "# example usage:",
            "# @bootstrap",
            "# def rec1(L,k,cur,count):",
            "# \tif count>=100000:",
            "# \t\tyield float('INF')",
            "# \tif cur+k+1>=len(L)-1:",
            "# \t\tyield L[cur]+2",
            "# \tif cur in d:",
            "# \t\tyield d[cur]",
            "# \tans = float('INF')",
            "# \tmini = float('INF')",
            "# \tfor i in range(k+1,0,-1):",
            "# \t\tif L[cur+i]<mini:",
            "# \t\t\tans = min(ans,1+L[cur]+(yield rec1(L,k,cur+i,count+1)))",
            "# \t\t\tmini = L[cur+i]",
            "# \td[cur] = ans",
            "# \tyield ans",
            "# the limit of recursion on cf is 10**6"
        ],
        "description": "Decorator to increase recursion limit using the bootstrap method with yield."
    },    
    "sf": {
        "prefix": "sf",
        "body": [
            "def SuffArr(st,flag=True):",
            "\tif flag:L = [ord(i) for i in st]",
            "\telse:L=st",
            "\tn = len(L)",
            "\tbuckets = [0] * (max(L) + 2)",
            "\tfor a in L:",
            "\t\tbuckets[a + 1] += 1",
            "\tfor b in range(1, len(buckets)):",
            "\t\tbuckets[b] += buckets[b - 1]",
            "\tisL = [1] * n",
            "\tfor i in reversed(range(n - 1)):",
            "\t\tisL[i] = +(L[i] > L[i + 1]) if L[i] != L[i + 1] else isL[i + 1]",
            "\tdef induced_sort(LMS):",
            "\t\tSA = [-1] * (n)",
            "\t\tSA.append(n)",
            "\t\tendpoint = buckets[1:]",
            "\t\tfor j in reversed(LMS):",
            "\t\t\tendpoint[L[j]] -= 1",
            "\t\t\tSA[endpoint[L[j]]] = j",
            "\t\tstartpoint = buckets[:-1]",
            "\t\tfor i in range(-1, n):",
            "\t\t\tj = SA[i] - 1",
            "\t\t\tif j >= 0 and isL[j]:",
            "\t\t\t\tSA[startpoint[L[j]]] = j",
            "\t\t\t\tstartpoint[L[j]] += 1",
            "\t\tSA.pop()",
            "\t\tendpoint = buckets[1:]",
            "\t\tfor i in reversed(range(n)):",
            "\t\t\tj = SA[i] - 1",
            "\t\t\tif j >= 0 and not isL[j]:",
            "\t\t\t\tendpoint[L[j]] -= 1",
            "\t\t\t\tSA[endpoint[L[j]]] = j",
            "\t\treturn SA",
            "\tisLMS = [+(i and isL[i - 1] and not isL[i]) for i in range(n)]",
            "\tisLMS.append(1)",
            "\tLMS = [i for i in range(n) if isLMS[i]]",
            "\tif len(LMS) > 1:",
            "\t\tSA = induced_sort(LMS)",
            "\t\tLMS2 = [i for i in SA if isLMS[i]]",
            "\t\tprev = -1",
            "\t\tj = 0",
            "\t\tfor i in LMS2:",
            "\t\t\ti1 = prev",
            "\t\t\ti2 = i",
            "\t\t\twhile prev >= 0 and L[i1] == L[i2]:",
            "\t\t\t\ti1 += 1",
            "\t\t\t\ti2 += 1",
            "\t\t\t\tif isLMS[i1] or isLMS[i2]:",
            "\t\t\t\t\tj -= isLMS[i1] and isLMS[i2]",
            "\t\t\t\t\tbreak",
            "\t\t\tj += 1",
            "\t\t\tprev = i",
            "\t\t\tSA[i] = j",
            "\t\tLMS = [LMS[i] for i in SuffArr([SA[i] for i in LMS],False)]",
            "\treturn induced_sort(LMS)",
            "",
            "def LCPArray(L,SA=None):",
            "\t# Longest Common prefix in between S[i:] and S[i+1:]",
            "\tif not SA:",
            "\t\tSA = SuffArr(L)",
            "\tn = len(L)",
            "\trank = [0] * n",
            "\tfor i in range(n):",
            "\t\trank[SA[i]] = i",
            "\tLCP = [0] * (n - 1)",
            "\tk = 0",
            "\tfor i in range(n):",
            "\t\tl = rank[i]",
            "\t\tif l==n-1:",
            "\t\t\tk = 0",
            "\t\t\tcontinue",
            "\t\tj = SA[l+1]",
            "\t\twhile i+k<n and L[i+k] == L[j+k]:",
            "\t\t\tk += 1",
            "\t\tLCP[l] = k",
            "\t\tk -= k > 0",
            "\treturn LCP",
            "",
            "def z_function(S):",
            "\t# return: the Z array, where Z[i] = length of the longest common prefix of S[i:] and S",
            "\tn = len(S)",
            "\tZ = [0] * n",
            "\tl = r = 0",
            "\tfor i in range(1, n):",
            "\t\tz = Z[i - l]",
            "\t\tif i + z >= r:",
            "\t\t\tz = max(r - i, 0)",
            "\t\t\twhile i + z < n and S[z] == S[i + z]:",
            "\t\t\t\tz += 1",
            "\t\t\tl, r = i, i + z",
            "\t\tZ[i] = z",
            "\tZ[0] = n",
            "\treturn Z",
            "",
            "def manacher(s):",
            "\t# returns longest palindrome in s",
            "\tt = '#' + '#'.join(s) + '#'",
            "\tn = len(t)",
            "\tL = [0] * n",
            "\tc = r = 0",
            "\tml = 0",
            "\tmc = 0",
            "\tfor i in range(n):",
            "\t\tmirror = 2*c-i",
            "\t\tif i<r:",
            "\t\t\tL[i] = min(r-i,L[mirror])",
            "\t\ta = i+L[i]+1",
            "\t\tb = i-L[i]-1",
            "\t\twhile a<n and b>=0 and t[a]==t[b]:",
            "\t\t\tL[i] += 1",
            "\t\t\ta += 1",
            "\t\t\tb -= 1",
            "\t\tif i+L[i]>r:",
            "\t\t\tc = i",
            "\t\t\tr = i+L[i]",
            "\t\tif L[i]>ml:",
            "\t\t\tml = L[i]",
            "\t\t\tmc = i",
            "\tstart = (mc-ml)//2",
            "\treturn s[start:start+ml]",
            "",
            "def SuffArray(s):",
            "\t# Starting position of ith suffix",
            "\t# in lexographic order",
            "\ts += \"$\"",
            "\tn = len(s)",
            "\tk = 0",
            "\trank = [ord(c) for c in s]",
            "\ttmp = [0] * n",
            "\tsa = list(range(n))",
            "\tdef sort_key(i):",
            "\t\treturn (rank[i], rank[i + (1 << k)] if i + (1 << k) < n else -1)",
            "\twhile True:",
            "\t\tsa.sort(key=sort_key)",
            "\t\ttmp[sa[0]] = 0",
            "\t\tfor i in range(1, n):",
            "\t\t\ttmp[sa[i]] = tmp[sa[i-1]] + (sort_key(sa[i-1]) != sort_key(sa[i]))",
            "\t\trank, tmp = tmp, rank",
            "\t\tk += 1",
            "\t\tif (1 << k) >= n:",
            "\t\t\tbreak",
            "\treturn sa"
        ],
        "description": "sf implementation"
    },
    "BIT": {
        "prefix": "BIT",
        "body": [
            "class BIT:",
            "\t#Faster than segment tree so use if possbile",
            "\tdef __init__(self, x):",
            "\t\t\"\"\"transform list into BIT\"\"\"",
            "\t\tself.bit = x",
            "\t\tfor i in range(len(x)):",
            "\t\t\tj = i | (i + 1)",
            "\t\t\tif j < len(x):",
            "\t\t\t\tx[j] += x[i]",
            "\tdef update(self, idx, x):",
            "\t\t\"\"\"updates bit[idx] += x\"\"\"",
            "\t\t#basically after that number greater greater than x will be added",
            "\t\twhile idx < len(self.bit):",
            "\t\t\tself.bit[idx] += x",
            "\t\t\tidx |= idx + 1",
            "\tdef query(self, end):",
            "\t\t\"\"\"calc sum(bit[:end])\"\"\"",
            "\t\t#gives sum of element before end",
            "\t\tx = 0",
            "\t\twhile end:",
            "\t\t\tx += self.bit[end - 1]",
            "\t\t\tend &= end - 1",
            "\t\treturn x",
            "\tdef findkth(self, k):",
            "\t\t\"\"\"Find largest idx such that sum(bit[:idx]) <= k\"\"\"",
            "\t\tidx = -1",
            "\t\tfor d in reversed(range(len(self.bit).bit_length())):",
            "\t\t\tright_idx = idx + (1 << d)",
            "\t\t\tif right_idx < len(self.bit) and k >= self.bit[right_idx]:",
            "\t\t\t\tidx = right_idx",
            "\t\t\t\tk -= self.bit[idx]",
            "\t\treturn idx + 1"
        ]
    },
    "segmentpoint": {
        "prefix": "segmentpoint",
        "body": [
            "class SegmentTree:",
            "\t#Remember to change the func content as well as the initializer to display the content",
            "\t@staticmethod",
            "\tdef func(a, b):",
            "\t\treturn max(a, b)",
            "\tdef __init__(self, data):",
            "\t\tself.n = len(data)",
            "\t\tself.tree = [0] * (self.n<<1)",
            "\t\tself.build(data)",
            "\tdef build(self, data):",
            "\t\tfor i in range(self.n):",
            "\t\t\tself.tree[self.n + i] = data[i]",
            "\t\tfor i in range(self.n - 1, 0, -1):",
            "\t\t\tself.tree[i] = self.func(self.tree[i<<1], self.tree[(i<<1) + 1])",
            "\tdef __getitem__(self,pos):",
            "\t\tif isinstance(pos,slice):",
            "\t\t\treturn self.query(pos.start,pos.stop)",
            "\t\treturn self.tree[pos+self.n]",
            "\tdef __setitem__(self,pos,value):",
            "\t\tpos += self.n",
            "\t\tself.tree[pos] = value",
            "\t\twhile pos > 1:",
            "\t\t\tpos >>= 1",
            "\t\t\tself.tree[pos] = self.func(self.tree[pos<<1], self.tree[(pos<<1) + 1])",
            "\tdef query(self, left, right):",
            "\t\t# Query the maximum value in the range [left, right)",
            "\t\tleft += self.n",
            "\t\tright += self.n",
            "\t\t# Change the initializer depending upon the self.func",
            "\t\tmax_val = float('-inf')",
            "\t\twhile left < right:",
            "\t\t\tif left&1:",
            "\t\t\t\tmax_val = self.func(max_val, self.tree[left])",
            "\t\t\t\tleft += 1",
            "\t\t\tif right&1:",
            "\t\t\t\tright -= 1",
            "\t\t\t\tmax_val = self.func(max_val, self.tree[right])",
            "\t\t\tleft >>= 1",
            "\t\t\tright >>= 1",
            "\t\treturn max_val",
            "\tdef __repr__(self):",
            "\t\tvalues = [str(self.query(i, i + 1)) for i in range(self.n)]",
            "\t\treturn f\"Seg[{', '.join(values)}]\""
        ],
        "description": "segmentpoint implementation"
    },
    "SparseTable": {
        "prefix": "sparsetable",
        "body": [
            "class SparseTable:",
            "\t@staticmethod",
            "\tdef func(a,b):",
            "\t\t# func(a,a) should be a",
            "\t\treturn gcd(a,b)",
            "\tdef __init__(self, arr):",
            "\t\tself.n = len(arr)",
            "\t\tself.table = [[0 for i in range(int((math.log(self.n, 2)+1)))] for j in range(self.n)]",
            "\t\tself.build(arr)",
            "\tdef build(self, arr):",
            "\t\tfor i in range(0, self.n):",
            "\t\t\tself.table[i][0] = arr[i]",
            "\t\tj = 1",
            "\t\twhile (1 << j) <= self.n:",
            "\t\t\ti = 0",
            "\t\t\twhile i <= self.n - (1 << j):",
            "\t\t\t\tself.table[i][j] = self.func(self.table[i][j - 1], self.table[i + (1 << (j - 1))][j - 1])",
            "\t\t\t\ti += 1",
            "\t\t\tj += 1",
            "\tdef query(self, L, R):",
            "\t\t# query from [L,R]",
            "\t\tj = (R-L+1).bit_length()-1",
            "\t\treturn self.func(self.table[L][j], self.table[R - (1 << j) + 1][j])",
            "\tdef __getitem__(self,k):",
            "\t\t# query from [k[0],k[1]-1]",
            "\t\tif isinstance(k,slice):",
            "\t\t\treturn self.query(k.start,k.stop-1)",
            "\t\treturn self.query(k,k)",
            "\tdef __repr__(self):",
            "\t\treturn f\"SparseTable({[self[i:i+1] for i in range(self.n)]})\""
        ],
        "description": "SparseTable implementation"
    },
    "dpheq": {
        "prefix": "dpheq",
        "body": [
            "class DiophantineEquations:",
            "\t\"\"\"",
            "\t\tused for solving equations of the form a*x + b*y = c,",
            "\t\tsolnll takes the lower limit as well",
            "\t\"\"\"",
            "\tdef __init__(self):",
            "\t\tpass",
            "\tdef euclidean_gcd(self,a, b):",
            "\t\t\"\"\"",
            "\t\t\teuclidean gcd , returns x and y such that",
            "\t\t\ta*x + b*y = gcd(a,b)",
            "\t\t\"\"\"",
            "\t\tif b == 0:",
            "\t\t\treturn a,1,0",
            "\t\tg,x1,y1 = self.euclidean_gcd(b, a % b)",
            "\t\tx = y1",
            "\t\ty = x1-(a//b)*y1",
            "\t\treturn g,x,y",
            "\tdef soln(self,a,b,c,t=10**18,t1=10**18):",
            "\t\t\"\"\"",
            "\t\t\treturn m and n such that a*m + b*n = c and 0<=m<=t and 0<=n<=t1",
            "\t\t\tdon't input t,t1 for any possible value",
            "\t\t\"\"\"",
            "\t\tg = gcd(a, b)",
            "\t\tif c%g!=0:",
            "\t\t\treturn -1,-1",
            "\t\t_, x, y = self.euclidean_gcd(a, b)",
            "\t\tk3 = x*(c//g)",
            "\t\tn1 = y*(c//g)",
            "\t\tk1 = max(math.ceil(-k3*g/b),math.ceil((n1-t1)/(a/g)))",
            "\t\tkmaxi = min(math.floor((t-k3)/(b/g)), math.floor(n1/(a/g)))",
            "\t\tif k1<=kmaxi:",
            "\t\t\tk = k1",
            "\t\t\tm = k3+k*(b//g)",
            "\t\t\tn = n1-k*(a//g)",
            "\t\t\treturn m, n",
            "\t\telse:",
            "\t\t\treturn -1,-1",
            "\tdef sollnll(self,a,b,c,t,t1,m_lower,n_lower):",
            "\t\t\"\"\"",
            "\t\t\treturn m and n such that a*m + b*n = c and",
            "\t\t\tm_lower <= m <= t and n_lower <= n <= t1",
            "\t\t\"\"\"",
            "\t\tg = gcd(a, b)",
            "\t\tif c % g != 0:",
            "\t\t\treturn -1, -1",
            "\t\t_, x, y = self.euclidean_gcd(a, b)",
            "\t\tk3 = x * (c // g)",
            "\t\tn1 = y * (c // g)",
            "\t\tk1 = max(math.ceil((m_lower - k3 * g) / b), math.ceil((n1 - t1) / (a / g)))",
            "\t\tkmaxi = min(math.floor((t - k3) / (b / g)), math.floor((n1 - n_lower) / (a / g)))",
            "\t\tif k1 <= kmaxi:",
            "\t\t\tk = k1",
            "\t\t\tm = k3 + k * (b // g)",
            "\t\t\tn = n1 - k * (a // g)",
            "\t\t\tif m_lower <= m <= t and n_lower <= n <= t1:",
            "\t\t\t\treturn m, n",
            "\t\t\telse:",
            "\t\t\t\treturn -1,-1",
            "\t\telse:",
            "\t\t\treturn -1, -1",
            "Leq = DiophantineEquations()"
        ],
        "description": "dpheq implementation"
    },
    "DSU": {
        "prefix": "dsu",
        "body": [
            "class UnionFind:",
            "\tdef __init__(self, n):",
            "\t\tself.parent = list(range(n))",
            "",
            "\tdef find(self, a):",
            "\t\tacopy = a",
            "\t\twhile a != self.parent[a]:",
            "\t\t\ta = self.parent[a]",
            "\t\twhile acopy != a:",
            "\t\t\tself.parent[acopy], acopy = a, self.parent[acopy]",
            "\t\treturn a",
            "",
            "\tdef union(self, a, b):",
            "\t\tself.parent[self.find(b)] = self.find(a)",
            "",
            "",
            "class DisjointSetUnion:",
            "\tdef __init__(self, n):",
            "\t\tself.parent = list(range(n))",
            "\t\t# self.s = set(self.parent)",
            "\t\tself.size = [1] * n",
            "",
            "\tdef find(self, a):",
            "\t\tacopy = a",
            "\t\twhile a != self.parent[a]:",
            "\t\t\ta = self.parent[a]",
            "\t\twhile acopy != a:",
            "\t\t\tself.parent[acopy], acopy = a, self.parent[acopy]",
            "\t\treturn a",
            "",
            "\tdef union(self, a, b):",
            "\t\ta, b = self.find(a), self.find(b)",
            "\t\tif a != b:",
            "\t\t\tif self.size[a] < self.size[b]:",
            "\t\t\t\ta, b = b, a",
            "\t\t\t# self.s.remove(b)",
            "\t\t\tself.parent[b] = a",
            "\t\t\tself.size[a] += self.size[b]",
            "",
            "\tdef set_size(self, a):",
            "\t\treturn self.size[self.find(a)]",
            "",
            "\tdef __len__(self):",
            "\t\treturn len(self.s)",
            "",
            "\tdef notfind(self, a):",
            "\t\tk = self.find(a)",
            "\t\tfor j in self.s:",
            "\t\t\tif j!=k:",
            "\t\t\t\treturn j",
            "\t\treturn -1"
            
        ],
        "description": "DSU implementation"
    },
    "shclass": {
        "prefix": "shclass",
        "body": [
            "HMOD = 2147483647",
            "HBASE1 = random.randrange(HMOD)",
            "HBASE2 = random.randrange(HMOD)",
            "class Hashing:",
            "\tdef __init__(self, s, mod=HMOD, base1=HBASE1, base2=HBASE2):",
            "\t\tself.mod, self.base1, self.base2 = mod, base1, base2",
            "\t\tself._len = _len = len(s)",
            "\t\tf_hash, f_pow = [0] * (_len + 1), [1] * (_len + 1)",
            "\t\ts_hash, s_pow = f_hash[:], f_pow[:]",
            "\t\tfor i in range(_len):",
            "\t\t\tf_hash[i + 1] = (base1 * f_hash[i] + s[i]) % mod",
            "\t\t\ts_hash[i + 1] = (base2 * s_hash[i] + s[i]) % mod",
            "\t\t\tf_pow[i + 1] = base1 * f_pow[i] % mod",
            "\t\t\ts_pow[i + 1] = base2 * s_pow[i] % mod",
            "\t\tself.f_hash, self.f_pow = f_hash, f_pow",
            "\t\tself.s_hash, self.s_pow = s_hash, s_pow",
            "\tdef hashed(self, start, stop):",
            "\t\treturn (",
            "\t\t\t(self.f_hash[stop] - self.f_pow[stop - start] * self.f_hash[start]) % self.mod,",
            "\t\t\t(self.s_hash[stop] - self.s_pow[stop - start] * self.s_hash[start]) % self.mod,",
            "\t\t)",
            "\tdef get_hashes(self, length):",
            "\t\treturn (",
            "\t\t\t[(self.f_hash[i + length] - self.f_pow[length] * self.f_hash[i]) % self.mod for i in range(self._len - length + 1)],",
            "\t\t\t[(self.s_hash[i + length] - self.s_pow[length] * self.s_hash[i]) % self.mod for i in range(self._len - length + 1)],",
            "\t\t)"
        ],
        "description": "shclass implementation"
    },
    "geometry": {
        "prefix": "geometry",
        "body": [
            "## here onwards, it is for intersection only, even the point class is different",
            "class Point:",
            "\tdef __init__(self, x, y):",
            "\t\tself.x = x",
            "\t\tself.y = y",
            "def onSegment(p, q, r):",
            "\tif ( (q.x <= max(p.x, r.x)) and (q.x >= min(p.x, r.x)) and",
            "\t\t   (q.y <= max(p.y, r.y)) and (q.y >= min(p.y, r.y))):",
            "\t\treturn True",
            "\treturn False",
            "def orientation(p, q, r):",
            "\t# to find the orientation of an ordered triplet (p,q,r)",
            "\t# function returns the following values:",
            "\t# 0 : Collinear points",
            "\t# 1 : Clockwise points",
            "\t# 2 : Counterclockwise",
            "\tval = ((q.y - p.y) * (r.x - q.x)) - ((q.x - p.x) * (r.y - q.y))",
            "\tif (val > 0):",
            "\t\treturn 1",
            "\telif (val < 0):",
            "\t\treturn 2",
            "\telse:",
            "\t\treturn 0",
            "def doIntersect(p1,q1,p2,q2):",
            "\to1 = orientation(p1, q1, p2)",
            "\to2 = orientation(p1, q1, q2)",
            "\to3 = orientation(p2, q2, p1)",
            "\to4 = orientation(p2, q2, q1)",
            "\tif ((o1 != o2) and (o3 != o4)):",
            "\t\treturn True",
            "\tif ((o1 == 0) and onSegment(p1, p2, q1)):",
            "\t\treturn True",
            "\tif ((o2 == 0) and onSegment(p1, q2, q1)):",
            "\t\treturn True",
            "\tif ((o3 == 0) and onSegment(p2, p1, q2)):",
            "\t\treturn True",
            "\tif ((o4 == 0) and onSegment(p2, q1, q2)):",
            "\t\treturn True",
            "\treturn False",
            "##",
            "## lines",
            "# 2d line: ax + by + c = 0  is  (a, b, c)",
            "#\t\t  ax + by + c = 0\t ((a, b, c),",
            "# 3d line: dx + ez + f = 0  is  (d, e, f),",
            "#\t\t  gy + hz + i = 0\t  (g, h, i))",
            "",
            "def get_2dline(p1, p2):",
            "\tif p1 == p2:",
            "\t\treturn (0, 0, 0)",
            "\t_p1, _p2 = min(p1, p2), max(p1, p2)",
            "\ta, b, c = _p2[1] - _p1[1], _p1[0] - _p2[0], _p1[1] * _p2[0] - _p1[0] * _p2[1]",
            "\tg = gcd(gcd(a, b), c)",
            "\treturn (a // g, b // g, c // g)",
            "dist = lambda p1, p2: sum((a - b) * (a - b) for a, b in zip(p1, p2))**0.5",
            "get_line = lambda p1, p2: map(get_2dline, combinations(p1, 2), combinations(p2, 2))",
            "is_parallel = lambda l1, l2: l1[0] * l2[1] == l2[0] * l1[1]",
            "is_same = lambda l1, l2: is_parallel(l1, l2) and (l1[1] * l2[2] == l2[1] * l1[2])",
            "collinear = lambda p1, p2, p3: is_same(get_2dline(p1, p2), get_2dline(p2, p3))",
            "intersect = (lambda l1, l2: None if is_parallel(l1, l2) else (",
            "\t(l2[1] * l1[2] - l1[1] * l2[2]) / (l2[0] * l1[1] - l1[0] * l2[1]),",
            "\t(l1[0] * l2[2] - l1[2] * l2[0]) / (l2[0] * l1[1] - l1[0] * l2[1]),",
            "))",
            "rotate = lambda p, theta, origin=(0, 0): (",
            "\torigin[0] + (p[0] - origin[0]) * math.cos(theta) - (p[1] - origin[1]) * math.sin(theta),",
            "\torigin[1] + (p[0] - origin[0]) * math.sin(theta) + (p[1] - origin[1]) * math.cos(theta),",
            ")",
            "##",
            "## polygons",
            "dist = lambda p1, p2: sum((a - b) * (a - b) for a, b in zip(p1, p2))**0.5",
            "perimeter = lambda *p: sum(dist(i, j) for i, j in zip(p, p[1:] + p[:1]))",
            "area = lambda *p: abs(sum(i[0] * j[1] - j[0] * i[1] for i, j in zip(p, p[1:] + p[:1]))) / 2",
            "is_in_circle = lambda p, c, r: sum(i * i - j * j for i, j in zip(p, c)) < r * r",
            "incircle_radius = lambda a, b, c: area(a, b, c) / (perimeter(a, b, c) / 2)",
            "circumcircle_radius = lambda a, b, c: (dist(a, b) * dist(b, c) * dist(c, a)) / (4 * area(a, b, c))",
            "##",
            "",
            "def convex_hull(P):",
            "\tif len(P)<=1:return P",
            "\tcross = lambda a,b,c: (a[0] - b[0]) * (c[1] - b[1]) - (a[1] - b[1]) * (c[0] - b[0])",
            "\tP = sorted(P)",
            "\tdef f(P):",
            "\t\tlower = []",
            "\t\tfor p in P:",
            "\t\t\twhile len(lower) >= 2 and cross(lower[-2], lower[-1], p) < 0:",
            "\t\t\t\tlower.pop()",
            "\t\t\tlower.append(p)",
            "\t\treturn lower",
            "\treturn f(P)[:-1]+f(P[::-1])[:-1]"
        ],
        "description": "geometry implementation"
    },
    "Tries": {
        "prefix": "tries",
        "body": [
            "",
            "class Trie:",
            "\tdef __init__(self, *words):",
            "\t\tself.root = {}",
            "\t\tfor word in words:",
            "\t\t\tself.add(word)",
            "",
            "\tdef add(self, word):",
            "\t\tcurrent_dict = self.root",
            "\t\tfor letter in word:",
            "\t\t\tcurrent_dict = current_dict.setdefault(letter, {})",
            "\t\tcurrent_dict[0] = True",
            "",
            "\tdef __contains__(self, word):",
            "\t\tcurrent_dict = self.root",
            "\t\tfor letter in word:",
            "\t\t\tif letter not in current_dict:",
            "\t\t\t\treturn False",
            "\t\t\tcurrent_dict = current_dict[letter]",
            "\t\treturn 0 in current_dict",
            "",
            "\tdef __delitem__(self, word):",
            "\t\tcurrent_dict = self.root",
            "\t\tnodes = [current_dict]",
            "\t\tfor letter in word:",
            "\t\t\tcurrent_dict = current_dict[letter]",
            "\t\t\tnodes.append(current_dict)",
            "\t\tdel current_dict[0]"
        ],
        "description": "Tries implementation"
    },
    "FFT": {
        "prefix": "fft",
        "body": [
            "class FastFFT:",
            "\t# This is a bit faster, one log n factor is less but it's accuracy is not 100%",
            "\t# use this when coeffecient does not matter(set coeffecient to 1 repeatedly)",
            "\t# or you could just risk it :)",
            "\tdef __init__(self, MOD=998244353):",
            "\t\tFastFFT.MOD = MOD",
            "\t\t# g = self.primitive_root_constexpr()",
            "\t\tg = 3",
            "\t\tig = pow(g, FastFFT.MOD - 2, FastFFT.MOD)",
            "\t\tFastFFT.W = [pow(g, (FastFFT.MOD - 1) >> i, FastFFT.MOD) for i in range(30)]",
            "\t\tFastFFT.iW = [pow(ig, (FastFFT.MOD - 1) >> i, FastFFT.MOD) for i in range(30)]",
            "\tdef primitive_root_constexpr(self):",
            "\t\tif FastFFT.MOD == 998244353:",
            "\t\t\treturn 3",
            "\t\telif FastFFT.MOD == 200003:",
            "\t\t\treturn 2",
            "\t\telif FastFFT.MOD == 167772161:",
            "\t\t\treturn 3",
            "\t\telif FastFFT.MOD == 469762049:",
            "\t\t\treturn 3",
            "\t\telif FastFFT.MOD == 754974721:",
            "\t\t\treturn 11",
            "\t\tdivs = [0] * 20",
            "\t\tdivs[0] = 2",
            "\t\tcnt = 1",
            "\t\tx = (FastFFT.MOD - 1) // 2",
            "\t\twhile x % 2 == 0:",
            "\t\t\tx //= 2",
            "\t\ti = 3",
            "\t\twhile i * i <= x:",
            "\t\t\tif x % i == 0:",
            "\t\t\t\tdivs[cnt] = i",
            "\t\t\t\tcnt += 1",
            "\t\t\t\twhile x % i == 0:",
            "\t\t\t\t\tx //= i",
            "\t\t\ti += 2",
            "\t\tif x > 1:",
            "\t\t\tdivs[cnt] = x",
            "\t\t\tcnt += 1",
            "\t\tg = 2",
            "\t\twhile 1:",
            "\t\t\tok = True",
            "\t\t\tfor i in range(cnt):",
            "\t\t\t\tif pow(g, (FastFFT.MOD - 1) // divs[i], FastFFT.MOD) == 1:",
            "\t\t\t\t\tok = False",
            "\t\t\t\t\tbreak",
            "\t\t\tif ok:",
            "\t\t\t\treturn g",
            "\t\t\tg += 1",
            "\tdef fft(self, k, f):",
            "\t\tfor l in range(k, 0, -1):",
            "\t\t\td = 1 << l - 1",
            "\t\t\tU = [1]",
            "\t\t\tfor i in range(d):",
            "\t\t\t\tU.append(U[-1] * FastFFT.W[l] % FastFFT.MOD)",
            "\t\t\tfor i in range(1 << k - l):",
            "\t\t\t\tfor j in range(d):",
            "\t\t\t\t\ts = i * 2 * d + j",
            "\t\t\t\t\tf[s], f[s + d] = (f[s] + f[s + d]) % FastFFT.MOD, U[j] * (f[s] - f[s + d]) % FastFFT.MOD",
            "\tdef ifft(self, k, f):",
            "\t\tfor l in range(1, k + 1):",
            "\t\t\td = 1 << l - 1",
            "\t\t\tfor i in range(1 << k - l):",
            "\t\t\t\tu = 1",
            "\t\t\t\tfor j in range(i * 2 * d, (i * 2 + 1) * d):",
            "\t\t\t\t\tf[j+d] *= u",
            "\t\t\t\t\tf[j], f[j + d] = (f[j] + f[j + d]) % FastFFT.MOD, (f[j] - f[j + d]) % FastFFT.MOD",
            "\t\t\t\t\tu = u * FastFFT.iW[l] % FastFFT.MOD",
            "\tdef convolve(self, A, B):",
            "\t\tn0 = len(A) + len(B) - 1",
            "\t\tk = (n0).bit_length()",
            "\t\tn = 1 << k",
            "\t\tA += [0] * (n - len(A))",
            "\t\tB += [0] * (n - len(B))",
            "\t\tself.fft(k, A)",
            "\t\tself.fft(k, B)",
            "\t\tA = [a * b % FastFFT.MOD for a, b in zip(A, B)]",
            "\t\tself.ifft(k, A)",
            "\t\tinv = pow(n, FastFFT.MOD - 2, FastFFT.MOD)",
            "\t\tdel A[n0:]",
            "\t\tfor i in range(n0):",
            "\t\t\tA[i] = (A[i]*inv)%FastFFT.MOD",
            "\t\treturn A",
            "",
            "class FFT:",
            "\tdef __init__(self, MOD=998244353,MOD1=469762049):",
            "\t\tFFT.MOD = MOD",
            "\t\tFFT.MOD1 = MOD1",
            "\t\tFFT.MOD2 = pow(MOD,MOD1-2,MOD1)",
            "\t\tFFT.mod_inv = (self.XT_GCD(MOD,MOD1)[1])%MOD1",
            "\t\t# g = self.primitive_root_constexpr()",
            "\t\tg = 3",
            "\t\tig = pow(g, FFT.MOD - 2, FFT.MOD)",
            "\t\tig1 = pow(g, FFT.MOD1 - 2, FFT.MOD1)",
            "\t\tFFT.W = [pow(g, (FFT.MOD - 1) >> i, FFT.MOD) for i in range(30)]",
            "\t\tFFT.W1 = [pow(g, (FFT.MOD1 - 1) >> i, FFT.MOD1) for i in range(30)]",
            "\t\tFFT.iW = [pow(ig, (FFT.MOD - 1) >> i, FFT.MOD) for i in range(30)]",
            "\t\tFFT.iW1 = [pow(ig1, (FFT.MOD1 - 1) >> i, FFT.MOD1) for i in range(30)]",
            "\tdef primitive_root_constexpr(self):",
            "\t\tif FFT.MOD == 998244353:",
            "\t\t\treturn 3",
            "\t\telif FFT.MOD == 200003:",
            "\t\t\treturn 2",
            "\t\telif FFT.MOD == 167772161:",
            "\t\t\treturn 3",
            "\t\telif FFT.MOD == 469762049:",
            "\t\t\treturn 3",
            "\t\telif FFT.MOD == 754974721:",
            "\t\t\treturn 11",
            "\t\tdivs = [0] * 20",
            "\t\tdivs[0] = 2",
            "\t\tcnt = 1",
            "\t\tx = (FFT.MOD - 1) // 2",
            "\t\twhile x % 2 == 0:",
            "\t\t\tx //= 2",
            "\t\ti = 3",
            "\t\twhile i * i <= x:",
            "\t\t\tif x % i == 0:",
            "\t\t\t\tdivs[cnt] = i",
            "\t\t\t\tcnt += 1",
            "\t\t\t\twhile x % i == 0:",
            "\t\t\t\t\tx //= i",
            "\t\t\ti += 2",
            "\t\tif x > 1:",
            "\t\t\tdivs[cnt] = x",
            "\t\t\tcnt += 1",
            "\t\tg = 2",
            "\t\twhile 1:",
            "\t\t\tok = True",
            "\t\t\tfor i in range(cnt):",
            "\t\t\t\tif pow(g, (FFT.MOD - 1) // divs[i], FFT.MOD) == 1:",
            "\t\t\t\t\tok = False",
            "\t\t\t\t\tbreak",
            "\t\t\tif ok:",
            "\t\t\t\treturn g",
            "\t\t\tg += 1",
            "\tdef fft(self, k, f,f1):",
            "\t\tfor l in range(k, 0, -1):",
            "\t\t\td = 1 << l - 1",
            "\t\t\tU = [(1,1)]",
            "\t\t\tfor i in range(d):",
            "\t\t\t\tU.append((U[-1][0] * FFT.W[l] % FFT.MOD,U[-1][1] * FFT.W1[l] % FFT.MOD1))",
            "\t\t\tfor i in range(1 << k - l):",
            "\t\t\t\tfor j in range(d):",
            "\t\t\t\t\ts = i * 2 * d + j",
            "\t\t\t\t\tf[s], f[s + d] = (f[s] + f[s + d]) % FFT.MOD, U[j][0] * (f[s] - f[s + d]) % FFT.MOD",
            "\t\t\t\t\tf1[s], f1[s + d] = (f1[s] + f1[s + d]) % FFT.MOD1, U[j][1] * (f1[s] - f1[s + d]) % FFT.MOD1",
            "\tdef ifft(self, k, f,f1):",
            "\t\tfor l in range(1, k + 1):",
            "\t\t\td = 1 << l - 1",
            "\t\t\tfor i in range(1 << k - l):",
            "\t\t\t\tu = 1",
            "\t\t\t\tu1 = 1",
            "\t\t\t\tfor j in range(i * 2 * d, (i * 2 + 1) * d):",
            "\t\t\t\t\tf[j+d] *= u",
            "\t\t\t\t\tf[j], f[j + d] = (f[j] + f[j + d]) % FFT.MOD, (f[j] - f[j + d]) % FFT.MOD",
            "\t\t\t\t\tu = u * FFT.iW[l] % FFT.MOD",
            "\t\t\t\t\tf1[j+d] *= u1",
            "\t\t\t\t\tf1[j], f1[j + d] = (f1[j] + f1[j + d]) % FFT.MOD1, (f1[j] - f1[j + d]) % FFT.MOD1",
            "\t\t\t\t\tu1 = u1 * FFT.iW1[l] % FFT.MOD1",
            "\tdef XT_GCD(self,a,b):",
            "\t\tif b == 0:",
            "\t\t\treturn a,1,0",
            "\t\tg,x1,y1 = self.XT_GCD(b,a%b)",
            "\t\tx = y1",
            "\t\ty = x1-(a//b)*y1",
            "\t\treturn g,x,y",
            "\tdef CRT(self,a, mod1, b, mod2):",
            "\t\tk = (a+(b-a)*self.mod_inv%mod2*mod1)%(mod1*mod2)",
            "\t\treturn k",
            "\tdef convolve(self, A, B):",
            "\t\tn0 = len(A) + len(B) - 1",
            "\t\tk = (n0).bit_length()",
            "\t\tn = 1 << k",
            "\t\tA += [0] * (n - len(A))",
            "\t\tB += [0] * (n - len(B))",
            "\t\tA1 = A[:]",
            "\t\tB1 = B[:]",
            "\t\tself.fft(k, A,A1)",
            "\t\tself.fft(k, B,B1)",
            "\t\tA = [a * b % FFT.MOD for a, b in zip(A, B)]",
            "\t\tA1 = [a * b % FFT.MOD1 for a, b in zip(A1, B1)]",
            "\t\tself.ifft(k, A,A1)",
            "\t\tinv = pow(n, FFT.MOD - 2, FFT.MOD)",
            "\t\tinv1 = pow(n, FFT.MOD1 - 2, FFT.MOD1)",
            "\t\tdel A[n0:]",
            "\t\tfor i in range(n0):",
            "\t\t\tA[i] = self.CRT(A[i]*inv,FFT.MOD,A1[i]*inv1,FFT.MOD1)",
            "\t\treturn A",
            ""
        ],
        "description": "FFT implementation"
    },
    "perseg": {
        "prefix": "perseg",
        "body": [
            "class PersistentSegmentTree:",
            "",
            "\t# Everything is 0 based indexing and [l,r]",
            "\tclass Node:",
            "\t\tdef __init__(self, value=0, left=None, right=None):",
            "\t\t\tself.value = value",
            "\t\t\tself.left = left",
            "\t\t\tself.right = right",
            "",
            "\t@staticmethod",
            "\tdef func(a, b):",
            "\t\treturn a+b",
            "\tdef __init__(self, data):",
            "\t\tself.n = len(data)",
            "\t\tself.versions = []",
            "\t\tself.versions.append(self._build(data))",
            "\tdef _build(self, data):",
            "\t\tstack = [(0, self.n - 1, False)]",
            "\t\tnodes = {}",
            "\t\twhile stack:",
            "\t\t\tleft, right, visited = stack.pop()",
            "\t\t\tif left == right:",
            "\t\t\t\tnodes[(left, right)] = self.Node(data[left])",
            "\t\t\telse:",
            "\t\t\t\tif visited:",
            "\t\t\t\t\tmid = (left + right) // 2",
            "\t\t\t\t\tleft_child = nodes[(left, mid)]",
            "\t\t\t\t\tright_child = nodes[(mid + 1, right)]",
            "\t\t\t\t\tnodes[(left, right)] = self.Node(self.func(left_child.value,right_child.value),left_child, right_child)",
            "\t\t\t\telse:",
            "\t\t\t\t\tstack.append((left, right, True))",
            "\t\t\t\t\tmid = (left + right) // 2",
            "\t\t\t\t\tstack.append((mid + 1, right, False))",
            "\t\t\t\t\tstack.append((left, mid, False))",
            "\t\treturn nodes[(0, self.n - 1)]",
            "",
            "\tdef update(self, version, pos, value):",
            "\t\t# Returns the root to the new tree, ",
            "\t\t# now you must add it to versions yourself",
            "\t\t# seg.versions[version] = seg.update(version, pos, value)",
            "\t\told_root = self.versions[version]",
            "\t\tstack, path = [(old_root, 0, self.n - 1)], []",
            "\t\twhile stack:",
            "\t\t\tnode, left, right = stack.pop()",
            "\t\t\tpath.append((node, left, right))",
            "\t\t\tif left == right:",
            "\t\t\t\tbreak",
            "\t\t\tmid = (left + right) // 2",
            "\t\t\tif pos <= mid:",
            "\t\t\t\tstack.append((node.left, left, mid))",
            "\t\t\telse:",
            "\t\t\t\tstack.append((node.right, mid + 1, right))",
            "",
            "\t\tnew_nodes = {}",
            "\t\tfor node, left, right in reversed(path):",
            "\t\t\tif left == right:",
            "\t\t\t\tk = value",
            "\t\t\t\t# k = self.func(node.value,value) # if i want to update",
            "\t\t\t\tnew_nodes[(left, right)] = self.Node(k)",
            "\t\t\telse:",
            "\t\t\t\tmid = (left + right) // 2",
            "\t\t\t\tleft_child = new_nodes.get((left, mid), node.left)",
            "\t\t\t\tright_child = new_nodes.get((mid + 1, right), node.right)",
            "\t\t\t\tnew_nodes[(left, right)] = self.Node(self.func(left_child.value,right_child.value),left_child, right_child)",
            "\t\treturn new_nodes[(0, self.n - 1)]",
            "",
            "\tdef create_version(self, version, pos, value):",
            "\t\tnew_root = self.update(version, pos, value)",
            "\t\tself.versions.append(new_root)",
            "\t\treturn len(self.versions) - 1",
            "",
            "\tdef query(self, version, ql, qr):",
            "\t\tnode, left, right = self.versions[version], 0, self.n - 1",
            "\t\tstack = [(node, left, right)]",
            "\t\tresult = 0 # change this depending on the problem",
            "\t\twhile stack:",
            "\t\t\tnode, left, right = stack.pop()",
            "\t\t\tif ql > right or qr < left:",
            "\t\t\t\tcontinue",
            "\t\t\tif ql <= left and right <= qr:",
            "\t\t\t\tresult = self.func(result,node.value)",
            "\t\t\telse:",
            "\t\t\t\tmid = (left + right) // 2",
            "\t\t\t\tstack.append((node.left, left, mid))",
            "\t\t\t\tstack.append((node.right, mid + 1, right))",
            "\t\treturn result"
        ],
        "description": "Persistent Segment Tree implementation"
    },
    "Binary Trie": {
        "prefix": "b_trie",
        "body": [
            "class Node():",
            "\tdef __init__(self):",
            "\t\tself.data=0",
            "\t\tself.left=None",
            "\t\tself.right=None",
            "\t\tself.count=0",
            "class Trie():",
            "\tdef __init__(self,k=30):",
            "\t\tself.root=Node()",
            "\t\tself.k = k",
            "\tdef add(self,val):",
            "\t\tself.temp=self.root",
            "\t\tfor i in range(self.k,-1,-1):",
            "\t\t\tif (val)&(1<<i):",
            "\t\t\t\tif not self.temp.right:",
            "\t\t\t\t\tself.temp.right=Node()",
            "\t\t\t\tself.temp=self.temp.right",
            "\t\t\t\tself.temp.count+=1",
            "\t\t\telse:",
            "\t\t\t\tif not self.temp.left:",
            "\t\t\t\t\tself.temp.left=Node()",
            "\t\t\t\tself.temp=self.temp.left",
            "\t\t\t\tself.temp.count+=1",
            "\t\tself.temp.data=val",
            "\tdef __delitem__(self,val):",
            "\t\tself.temp=self.root",
            "\t\tfor i in range(self.k,-1,-1):",
            "\t\t\tif val&(1<<i):",
            "\t\t\t\tself.temp=self.temp.right",
            "\t\t\t\tself.temp.count-=1",
            "\t\t\telse:",
            "\t\t\t\tself.temp=self.temp.left",
            "\t\t\t\tself.temp.count-=1",
            "\tdef query_max(self,val):",
            "\t\tself.temp=self.root",
            "\t\tfor i in range(self.k,-1,-1):",
            "\t\t\tif val&(1<<i):",
            "\t\t\t\tif self.temp.left and self.temp.left.count>0:",
            "\t\t\t\t\tself.temp=self.temp.left",
            "\t\t\t\telif self.temp.right and self.temp.right.count>0:",
            "\t\t\t\t\tself.temp=self.temp.right",
            "\t\t\telse:",
            "\t\t\t\tif self.temp.right and self.temp.right.count>0:",
            "\t\t\t\t\tself.temp=self.temp.right",
            "\t\t\t\telif self.temp.left and self.temp.left.count>0:",
            "\t\t\t\t\tself.temp=self.temp.left",
            "\t\treturn val^self.temp.data",
            "\tdef query_min(self,val):",
            "\t\tself.temp=self.root",
            "\t\tfor i in range(self.k,-1,-1):",
            "\t\t\tif val&(1<<i)==0:",
            "\t\t\t\tif self.temp.left and self.temp.left.count>0:",
            "\t\t\t\t\tself.temp=self.temp.left",
            "\t\t\t\telif self.temp.right and self.temp.right.count>0:",
            "\t\t\t\t\tself.temp=self.temp.right",
            "\t\t\telse:",
            "\t\t\t\tif self.temp.right and self.temp.right.count>0:",
            "\t\t\t\t\tself.temp=self.temp.right",
            "\t\t\t\telif self.temp.left and self.temp.left.count>0:",
            "\t\t\t\t\tself.temp=self.temp.left",
            "\t\treturn val^self.temp.data"
        ],
        "description": "Binary Trie implementation"
    },
    "xdict": {
        "prefix": "xdict",
        "body": [
            "class Xdict:",
            "\tdef __init__(self,L=[],flag=1):",
            "\t\tself.d = {}",
            "\t\tself.flag = flag",
            "\t\tfor j in L:self[j]+=1",
            "\tdef __setitem__(self,key,value):",
            "\t\tself.d[w(key)] = value",
            "\tdef __getitem__(self,key):",
            "\t\treturn self.d.get(w(key),0) if self.flag else self.d[w(key)]",
            "\tdef keys(self):",
            "\t\treturn (w(i) for i in self.d)",
            "\tdef values(self):",
            "\t\treturn (self.d[i] for i in self.d)",
            "\tdef items(self):",
            "\t\treturn ((w(i),self.d[i]) for i in self.d)",
            "\tdef __repr__(self):",
            "\t\treturn '{'+','.join([str(w(i))+':'+str(self.d[i]) for i in self.d])+'}'",
            "\tdef __delitem__(self,val):",
            "\t\tdel self.d[w(val)]",
            "\tdef get(self,key,other):",
            "\t\treturn self.d.get(w(key),other)",
            "\tdef __contains__(self,key):",
            "\t\treturn w(key) in self.d",
            "\tdef __len__(self):",
            "\t\treturn len(self.d)",
            "\tdef clear(self):",
            "\t\tself.d.clear()",
            "\tdef __iter__(self):",
            "\t\treturn iter(self.keys())",
            "",
            "class Xset:",
            "\tdef __init__(self,L=[]):",
            "\t\tself.s = set()",
            "\t\tfor j in L:self.add(j)",
            "\tdef add(self,key):",
            "\t\tself.s.add(w(key))",
            "\tdef keys(self):",
            "\t\treturn (w(i) for i in self.s)",
            "\tdef __repr__(self):",
            "\t\treturn '{'+','.join([str(w(i)) for i in self.s])+'}'",
            "\tdef remove(self,val):",
            "\t\tself.s.remove(w(val))",
            "\tdef __contains__(self,key):",
            "\t\treturn w(key) in self.s",
            "\tdef __len__(self):",
            "\t\treturn len(self.s)",
            "\tdef clear(self):",
            "\t\tself.s.clear()",
            "\tdef __iter__(self):",
            "\t\treturn iter(self.keys())"
        ],
        "description": "xdict and xset implementation"
    }, 
    "hld": {
        "prefix": "hld",
        "body": [
            "class HLD:",
            "\tdef __init__(self, adj, values, root=0,func=max,unit=float('-inf')):",
            "\t\tself.adj = adj",
            "\t\tself.values = values",
            "\t\tself.parent = [-1] * len(adj)",
            "\t\tself.depth = [0] * len(adj)",
            "\t\tself.size = [0] * len(adj)",
            "\t\tself.heavy = [-1] * len(adj)",
            "\t\tself.head = [0] * len(adj)",
            "\t\tself.pos = [0] * len(adj)",
            "\t\tself.flat = [0] * len(adj)",
            "\t\tself.unit = unit",
            "\t\tself.func = func",
            "\t\tself._dfs(root)",
            "\t\tself._decompose(root)",
            "\t\tself.seg = SegmentTree([self.values[self.flat[i]] for i in range(len(self.adj))],func,unit)",
            "\tdef _dfs(self,start=0):",
            "\t\tvisited = [False] * len(self.adj)",
            "\t\tstack = [start]",
            "\t\twhile stack:",
            "\t\t\tstart = stack[-1]",
            "\t\t\tif not visited[start]:",
            "\t\t\t\tvisited[start] = True",
            "\t\t\t\tfor child in self.adj[start]:",
            "\t\t\t\t\tif not visited[child]:",
            "\t\t\t\t\t\tself.parent[child] = start",
            "\t\t\t\t\t\tself.depth[child] = self.depth[start]+1",
            "\t\t\t\t\t\tstack.append(child)",
            "\t\t\telse:",
            "\t\t\t\tself.size[stack.pop()] = 1",
            "\t\t\t\tk = 0",
            "\t\t\t\tfor child in self.adj[start]:",
            "\t\t\t\t\tif self.parent[start]!=child:",
            "\t\t\t\t\t\tself.size[start] += self.size[child]",
            "\t\t\t\t\t\tif self.size[child]>k:",
            "\t\t\t\t\t\t\tk = self.size[child]",
            "\t\t\t\t\t\t\tself.heavy[start] = child",
            "\t\treturn visited",
            "\tdef _decompose(self, root):",
            "\t\tstack = [(root,root)]",
            "\t\ttime = 0",
            "\t\twhile stack:",
            "\t\t\tu, h = stack.pop()",
            "\t\t\tself.head[u] = h",
            "\t\t\tself.flat[time] = u",
            "\t\t\tself.pos[u] = time",
            "\t\t\ttime += 1",
            "\t\t\tfor v in reversed(self.adj[u]):",
            "\t\t\t\tif v!=self.parent[u] and v!=self.heavy[u]:",
            "\t\t\t\t\tstack.append((v, v))",
            "\t\t\tif self.heavy[u] != -1:",
            "\t\t\t\tstack.append((self.heavy[u], h))",
            "\tdef query(self, u, v):",
            "\t\tres = self.unit",
            "\t\twhile self.head[u] != self.head[v]:",
            "\t\t\tif self.depth[self.head[u]] < self.depth[self.head[v]]:",
            "\t\t\t\tu, v = v, u",
            "\t\t\tres = self.func(res, self.seg.query(self.pos[self.head[u]], self.pos[u] + 1))",
            "\t\t\tu = self.parent[self.head[u]]",
            "\t\tif self.depth[u] > self.depth[v]:",
            "\t\t\tu, v = v, u",
            "\t\treturn self.func(res, self.seg.query(self.pos[u], self.pos[v] + 1))",
            "\tdef update(self, u, value):",
            "\t\tself.seg.update(self.pos[u], value)",
            "\tdef update_path(self, u, v, value):",
            "\t\twhile self.head[u] != self.head[v]:",
            "\t\t\tif self.depth[self.head[u]] < self.depth[self.head[v]]:",
            "\t\t\t\tu, v = v, u",
            "\t\t\tself.seg.range_update(self.pos[self.head[u]], self.pos[u], value)",
            "\t\t\tu = self.parent[self.head[u]]",
            "\t\tif self.depth[u] > self.depth[v]:",
            "\t\t\tu, v = v, u",
            "\t\tself.seg.range_update(self.pos[u], self.pos[v], value)",
            "\tdef add_to_subtree(self, u, value):",
            "\t\tself.seg.range_update(self.pos[u], self.pos[u] + self.size[u] - 1, value)"
        ],
        "description": "hld implementation"
    },
    "Bitarray": {
        "prefix": "bitarray",
        "body": [
            "class BitSet:",
            "\tADDRESS_BITS_PER_WORD = 12",
            "\tBITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD",
            "\tWORD_MASK = -1",
            "\tdef __init__(self, sz):",
            "\t\tself.sz = sz",
            "\t\tself.words = [0] * (self._wordIndex(sz - 1) + 1)",
            "\tdef _wordIndex(self, bitIndex):",
            "\t\tif bitIndex >= self.sz:",
            "\t\t\traise ValueError(\"out of bound index\", bitIndex)",
            "\t\treturn bitIndex >> BitSet.ADDRESS_BITS_PER_WORD",
            "\tdef flip(self, bitIndex):",
            "\t\twordIndex = self._wordIndex(bitIndex)",
            "\t\tself.words[wordIndex] ^= 1 << (bitIndex % BitSet.BITS_PER_WORD)",
            "\tdef flip_range(self, l, r):",
            "\t\tstartWordIndex = self._wordIndex(l)",
            "\t\tendWordIndex = self._wordIndex(r)",
            "\t\tfirstWordMask = BitSet.WORD_MASK << (l % BitSet.BITS_PER_WORD)",
            "\t\trem = (r+1) % BitSet.BITS_PER_WORD",
            "\t\tlastWordMask = BitSet.WORD_MASK if rem == 0 else ~(BitSet.WORD_MASK << rem)",
            "\t\tif startWordIndex == endWordIndex:",
            "\t\t\tself.words[startWordIndex] ^= (firstWordMask & lastWordMask)",
            "\t\telse:",
            "\t\t\tself.words[startWordIndex] ^= firstWordMask",
            "\t\t\tfor i in range(startWordIndex + 1, endWordIndex):",
            "\t\t\t\tself.words[i] ^= BitSet.WORD_MASK",
            "\t\t\tself.words[endWordIndex] ^= lastWordMask",
            "\tdef __setitem__(self, bitIndex, value):",
            "\t\twordIndex = self._wordIndex(bitIndex)",
            "\t\tif value:",
            "\t\t\tself.words[wordIndex] |= 1 << (bitIndex % BitSet.BITS_PER_WORD)",
            "\t\telse:",
            "\t\t\tself.words[wordIndex] &= ~(1 << (bitIndex % BitSet.BITS_PER_WORD))",
            "\tdef __getitem__(self, bitIndex):",
            "\t\twordIndex = self._wordIndex(bitIndex)",
            "\t\treturn self.words[wordIndex] & (1 << (bitIndex % BitSet.BITS_PER_WORD)) != 0",
            "\tdef nextSetBit(self, fromIndex):",
            "\t\twordIndex = self._wordIndex(fromIndex)",
            "\t\tword = self.words[wordIndex] & (BitSet.WORD_MASK << (fromIndex % BitSet.BITS_PER_WORD))",
            "",
            "\t\twhile True:",
            "\t\t\tif word != 0:",
            "\t\t\t\treturn wordIndex * BitSet.BITS_PER_WORD + (word & -word).bit_length() - 1",
            "\t\t\twordIndex += 1",
            "\t\t\tif wordIndex > len(self.words) - 1:",
            "\t\t\t\treturn -1",
            "\t\t\tword = self.words[wordIndex]",
            "\tdef nextClearBit(self, fromIndex):",
            "\t\twordIndex = self._wordIndex(fromIndex)",
            "\t\tword = ~self.words[wordIndex] & (BitSet.WORD_MASK << (fromIndex % BitSet.BITS_PER_WORD))",
            "",
            "\t\twhile True:",
            "\t\t\tif word != 0:",
            "\t\t\t\tindex = wordIndex * BitSet.BITS_PER_WORD + (word & -word).bit_length() - 1",
            "\t\t\t\treturn index if index < self.sz else - 1",
            "\t\t\twordIndex += 1",
            "\t\t\tif wordIndex > len(self.words) - 1:",
            "\t\t\t\treturn -1",
            "\t\t\tword = ~self.words[wordIndex]",
            "\tdef lastSetBit(self):",
            "\t\twordIndex = len(self.words) - 1",
            "\t\tword = self.words[wordIndex]",
            "",
            "\t\twhile wordIndex >= 0:",
            "\t\t\tif word != 0:",
            "\t\t\t\treturn wordIndex * BitSet.BITS_PER_WORD + (word.bit_length() - 1 if word > 0 else  BitSet.BITS_PER_WORD - 1)",
            "\t\t\twordIndex -= 1",
            "\t\t\tword = self.words[wordIndex]",
            "\t\treturn -1",
            "\tdef __str__(self):",
            "\t\tres = []",
            "\t\tst = 0",
            "\t\twhile True:",
            "\t\t\ti = self.nextSetBit(st)",
            "\t\t\tif i != -1:",
            "\t\t\t\tres += [0] * (i - st)",
            "\t\t\t\tj = self.nextClearBit(i)",
            "\t\t\t\tif j != -1:",
            "\t\t\t\t\tres += [1] * (j-i)",
            "\t\t\t\t\tst = j",
            "\t\t\t\telse:",
            "\t\t\t\t\tres += [1] * (self.sz - i)",
            "\t\t\t\t\tbreak",
            "\t\t\telse:",
            "\t\t\t\tres += [0] * (self.sz - st)",
            "\t\t\t\tbreak",
            "",
            "\t\treturn \"\".join(str(v) for v in res)",
            "\tdef __repr__(self):",
            "\t\treturn \"Bitset(%s)\" % str(self)",
            "\tdef __iter__(self):",
            "\t\tfor i in self[:]:",
            "\t\t\tyield i",
            "\tdef __len__(self):",
            "\t\treturn self.sz",
            "\tdef __or__(self, other):",
            "\t\tif self.sz != other.sz:",
            "\t\t\traise ValueError(\"BitSets must be of equal size\")",
            "\t\tres = BitSet(self.sz)",
            "\t\tres.words = [a | b for a, b in zip(self.words, other.words)]",
            "\t\treturn res",
            "\tdef __add__(self, other):",
            "\t\tif self.sz != other.sz:",
            "\t\t\traise ValueError(\"BitSets must be of equal size\")",
            "\t\tres = BitSet(self.sz)",
            "\t\tcarry = 0",
            "\t\tfor i in range(len(self.words)):",
            "\t\t\ttotal = self.words[i] + other.words[i] + carry",
            "\t\t\tres.words[i] = total & BitSet.WORD_MASK",
            "\t\t\tcarry = total >> BitSet.BITS_PER_WORD",
            "\t\treturn res",
            "\tdef __and__(self, other):",
            "\t\tif self.sz != other.sz:",
            "\t\t\traise ValueError(\"BitSets must be of equal size\")",
            "\t\tres = BitSet(self.sz)",
            "\t\tres.words = [a & b for a, b in zip(self.words, other.words)]",
            "\t\treturn res",
            "\tdef __xor__(self, other):",
            "\t\tif self.sz != other.sz:",
            "\t\t\traise ValueError(\"BitSets must be of equal size\")",
            "\t\tres = BitSet(self.sz)",
            "\t\tres.words = [a ^ b for a, b in zip(self.words, other.words)]",
            "\t\treturn res",
            "\tdef __invert__(self):",
            "\t\tres = BitSet(self.sz)",
            "\t\tres.words = [~a & BitSet.WORD_MASK for a in self.words]",
            "\t\treturn res",
            "\tdef add(self, val):",
            "\t\tself.flip_range(val, self.nextClearBit(val))",
            "\tdef rem(self, val):",
            "\t\tself.flip_range(val, self.nextSetBit(val))"
        ],
        "description": "Bitarray implementation"
    },
    "graphadv": {
        "prefix": "graphadv",
        "body": [
            "INF = float(\"inf\")",
            "class Dinic:",
            "\tdef __init__(self, n):",
            "\t\tself.lvl = [0] * n",
            "\t\tself.ptr = [0] * n",
            "\t\tself.q = [0] * n",
            "\t\tself.adj = [[] for _ in range(n)]",
            "\tdef add_edge(self, a, b, c, rcap=0):",
            "\t\tself.adj[a].append([b, len(self.adj[b]), c, 0])",
            "\t\tself.adj[b].append([a, len(self.adj[a]) - 1, rcap, 0])",
            "\tdef dfs(self, v, t, f):",
            "\t\tif v == t or not f:",
            "\t\t\treturn f",
            "\t\tfor i in range(self.ptr[v], len(self.adj[v])):",
            "\t\t\te = self.adj[v][i]",
            "\t\t\tif self.lvl[e[0]] == self.lvl[v] + 1:",
            "\t\t\t\tp = self.dfs(e[0], t, min(f, e[2] - e[3]))",
            "\t\t\t\tif p:",
            "\t\t\t\t\tself.adj[v][i][3] += p",
            "\t\t\t\t\tself.adj[e[0]][e[1]][3] -= p",
            "\t\t\t\t\treturn p",
            "\t\t\tself.ptr[v] += 1",
            "\t\treturn 0",
            "\tdef calc(self, s, t):",
            "\t\tflow, self.q[0] = 0, s",
            "\t\tfor l in range(31):  # l = 30 maybe faster for random data",
            "\t\t\twhile True:",
            "\t\t\t\tself.lvl, self.ptr = [0] * len(self.q), [0] * len(self.q)",
            "\t\t\t\tqi, qe, self.lvl[s] = 0, 1, 1",
            "\t\t\t\twhile qi < qe and not self.lvl[t]:",
            "\t\t\t\t\tv = self.q[qi]",
            "\t\t\t\t\tqi += 1",
            "\t\t\t\t\tfor e in self.adj[v]:",
            "\t\t\t\t\t\tif not self.lvl[e[0]] and (e[2] - e[3]) >> (30 - l):",
            "\t\t\t\t\t\t\tself.q[qe] = e[0]",
            "\t\t\t\t\t\t\tqe += 1",
            "\t\t\t\t\t\t\tself.lvl[e[0]] = self.lvl[v] + 1",
            "\t\t\t\tp = self.dfs(s, t, INF)",
            "\t\t\t\twhile p:",
            "\t\t\t\t\tflow += p",
            "\t\t\t\t\tp = self.dfs(s, t, INF)",
            "\t\t\t\tif not self.lvl[t]:",
            "\t\t\t\t\tbreak",
            "\t\treturn flow",
            "",
            "class AuxiliaryTree:",
            "\tdef __init__(self, edge, root = 0):",
            "\t\tself.n = len(edge)",
            "\t\tself.order = [-1] * self.n",
            "\t\tself.path = [-1] * (self.n-1)",
            "\t\tself.depth = [0] * self.n",
            "\t\tif self.n == 1: return",
            "\t\tparent = [-1] * self.n",
            "\t\tque = [root]",
            "\t\tt = -1",
            "\t\twhile que:",
            "\t\t\tu = que.pop()",
            "\t\t\tself.path[t] = parent[u]",
            "\t\t\tt += 1",
            "\t\t\tself.order[u] = t",
            "\t\t\tfor v in edge[u]:",
            "\t\t\t\tif self.order[v] == -1:",
            "\t\t\t\t\tque.append(v)",
            "\t\t\t\t\tparent[v] = u",
            "\t\t\t\t\tself.depth[v] = self.depth[u] + 1",
            "\t\tself.n -= 1",
            "\t\tself.h = self.n.bit_length()",
            "\t\tself.data = [0] * (self.n * self.h)",
            "\t\tself.data[:self.n] = [self.order[u] for u in self.path]",
            "\t\tfor i in range(1, self.h):",
            "\t\t\tfor j in range(self.n - (1<<i) + 1):",
            "\t\t\t\tself.data[i*self.n + j] = min(self.data[(i-1)*self.n + j], self.data[(i-1)*self.n + j+(1<<(i-1))])",
            "",
            "\tdef lca(self, u, v):",
            "\t\tif u == v: return u",
            "\t\tl = self.order[u]",
            "\t\tr = self.order[v]",
            "\t\tif l > r:",
            "\t\t\tl,r = r,l",
            "\t\tlevel = (r - l).bit_length() - 1",
            "\t\treturn self.path[min(self.data[level*self.n + l], self.data[level*self.n + r-(1<<level)])]",
            "",
            "\tdef dis(self, u, v):",
            "\t\tif u == v: return 0",
            "\t\tl = self.order[u]",
            "\t\tr = self.order[v]",
            "\t\tif l > r:",
            "\t\t\tl,r = r,l",
            "\t\tlevel = (r - l).bit_length() - 1",
            "\t\tp = self.path[min(self.data[level*self.n + l], self.data[level*self.n + r-(1<<level)])]",
            "\t\treturn self.depth[u] + self.depth[v] - 2 * self.depth[p]",
            "",
            "\tdef make(self, vs):",
            "\t\tk = len(vs)",
            "\t\tvs.sort(key = self.order.__getitem__)",
            "",
            "\t\tpar = dict()",
            "\t\tedge = dict()",
            "\t\tedge[vs[0]] = []",
            "",
            "\t\tst = [vs[0]]",
            "",
            "\t\tfor i in range(k - 1):",
            "\t\t\tl = self.order[vs[i]]",
            "\t\t\tr = self.order[vs[i+1]]",
            "\t\t\tlevel = (r - l).bit_length() - 1",
            "\t\t\tw = self.path[min(self.data[level*self.n + l], self.data[level*self.n + r-(1<<level)])]",
            "\t\t\tif w != vs[i]:",
            "\t\t\t\tp = st.pop()",
            "\t\t\t\twhile st and self.depth[w] < self.depth[st[-1]]:",
            "\t\t\t\t\tpar[p] = st[-1]",
            "\t\t\t\t\tedge[st[-1]].append(p)",
            "\t\t\t\t\tp = st.pop()",
            "",
            "\t\t\t\tif not st or st[-1] != w:",
            "\t\t\t\t\tst.append(w)",
            "\t\t\t\t\tedge[w] = [p]",
            "\t\t\t\telse:",
            "\t\t\t\t\tedge[w].append(p)",
            "\t\t\t\tpar[p] = w",
            "",
            "\t\t\tst.append(vs[i+1])",
            "\t\t\tedge[vs[i+1]] = []",
            "",
            "\t\tfor i in range(len(st) - 1):",
            "\t\t\tedge[st[i]].append(st[i+1])",
            "\t\t\tpar[st[i+1]] = st[i]",
            "",
            "\t\tpar[st[0]] = -1",
            "\t\treturn st[0], edge, par",
            "",
            "class binary_lift:",
            "\tdef __init__(self, graph, f=max, root=0, flag=False):",
            "\t\tn = len(graph)",
            "\t\tparent = [-1] * (n + 1)",
            "\t\tdepth = self.depth = [-1] * n",
            "\t\tbfs = [root]",
            "\t\tdepth[root] = 0",
            "\t\tdata = [0]*n",
            "\t\tfor node in bfs:",
            "\t\t\t# for nei,w in graph[node]:",
            "\t\t\tfor nei in graph[node]:",
            "\t\t\t\tif depth[nei] == -1:",
            "\t\t\t\t\t# data[nei] = w",
            "\t\t\t\t\tparent[nei] = node",
            "\t\t\t\t\tdepth[nei] = depth[node] + 1",
            "\t\t\t\t\tbfs.append(nei)",
            "\t\tparent = self.parent = [parent]",
            "\t\tself.f = f",
            "\t\tif flag:",
            "\t\t\tdata = self.data = [data]",
            "\t\t\tfor _ in range(max(depth).bit_length()):",
            "\t\t\t\told_data = data[-1]",
            "\t\t\t\told_parent = parent[-1]",
            "\t\t\t\tdata.append([f(val, old_data[p]) for val,p in zip(old_data, old_parent)])",
            "\t\t\t\tparent.append([old_parent[p] for p in old_parent])",
            "\t\telse:",
            "\t\t\tfor _ in range(max(depth).bit_length()):",
            "\t\t\t\told_parent = parent[-1]",
            "\t\t\t\tparent.append([old_parent[p] for p in old_parent])",
            "\tdef lca(self, a, b):",
            "\t\tdepth = self.depth",
            "\t\tparent = self.parent",
            "\t\tif depth[a] < depth[b]:",
            "\t\t\ta,b = b,a",
            "\t\td = depth[a] - depth[b]",
            "\t\tfor i in range(d.bit_length()):",
            "\t\t\tif (d >> i) & 1:",
            "\t\t\t\ta = parent[i][a]",
            "\t\tfor i in range(depth[a].bit_length())[::-1]:",
            "\t\t\tif parent[i][a] != parent[i][b]:",
            "\t\t\t\ta = parent[i][a]",
            "\t\t\t\tb = parent[i][b]",
            "\t\tif a != b:",
            "\t\t\treturn parent[0][a]",
            "\t\telse:",
            "\t\t\treturn a",
            "\tdef distance(self, a, b):",
            "\t\treturn self.depth[a] + self.depth[b] - 2 * self.depth[self.lca(a,b)]",
            "\tdef kth_ancestor(self, a, k):",
            "\t\tparent = self.parent",
            "\t\tif self.depth[a] < k:",
            "\t\t\treturn -1",
            "\t\tfor i in range(k.bit_length()):",
            "\t\t\tif (k >> i) & 1:",
            "\t\t\t\ta = parent[i][a]",
            "\t\treturn a",
            "\tdef __call__(self, a, b, c=0):",
            "\t\tdepth = self.depth",
            "\t\tparent = self.parent",
            "\t\tdata = self.data",
            "\t\tf = self.f",
            "\t\tc = self.lca(a, b)",
            "\t\tval = c",
            "\t\tfor x,d in (a, depth[a] - depth[c]), (b, depth[b] - depth[c]):",
            "\t\t\tfor i in range(d.bit_length()):",
            "\t\t\t\tif (d >> i) & 1:",
            "\t\t\t\t\tval = f(val, data[i][x])",
            "\t\t\t\t\tx = parent[i][x]",
            "\t\treturn val"
        ],
        "description": "graphadv implementation"
    },
    "2sat": {
        "prefix": "2sat",
        "body": [
            "def kahn(graph):",
            "\tn = len(graph)",
            "\tindeg, idx = [0] * n, [0] * n",
            "\tfor i in range(n):",
            "\t\tfor e in graph[i]:",
            "\t\t\tindeg[e] += 1",
            "\tq, res = [], []",
            "\tfor i in range(n):",
            "\t\tif indeg[i] == 0:",
            "\t\t\tq.append(i)",
            "\tnr = 0",
            "\twhile q:",
            "\t\tres.append(q.pop())",
            "\t\tidx[res[-1]], nr = nr, nr + 1",
            "\t\tfor e in graph[res[-1]]:",
            "\t\t\tindeg[e] -= 1",
            "\t\t\tif indeg[e] == 0:",
            "\t\t\t\tq.append(e)",
            "\treturn res, idx, nr == n",
            "",
            "def find_SCC(graph):",
            "\tSCC, S, P = [], [], []",
            "\tdepth = [0] * len(graph)",
            "\tstack = list(range(len(graph)))",
            "\twhile stack:",
            "\t\tnode = stack.pop()",
            "\t\tif node < 0:",
            "\t\t\td = depth[~node] - 1",
            "\t\t\tif P[-1] > d:",
            "\t\t\t\tSCC.append(S[d:])",
            "\t\t\t\tdel S[d:], P[-1]",
            "\t\t\t\tfor node in SCC[-1]:",
            "\t\t\t\t\tdepth[node] = -1",
            "\t\telif depth[node] > 0:",
            "\t\t\twhile P[-1] > depth[node]:",
            "\t\t\t\tP.pop()",
            "\t\telif depth[node] == 0:",
            "\t\t\tS.append(node)",
            "\t\t\tP.append(len(S))",
            "\t\t\tdepth[node] = len(S)",
            "\t\t\tstack.append(~node)",
            "\t\t\tstack += graph[node]",
            "\treturn SCC[::-1]",
            "",
            "class TwoSat:",
            "\tdef __init__(self, n):",
            "\t\tself.n = n",
            "\t\tself.graph = [[] for _ in range(2 * n)]",
            "\tdef negate(self, x):",
            "\t\treturn x+self.n if x<self.n else x-self.n",
            "\tdef _imply(self, x, y):",
            "\t\t# agar x hoga , toh y hoga",
            "\t\tself.graph[x].append(y)",
            "\t\tself.graph[self.negate(y)].append(self.negate(x))",
            "\tdef either(self, x, y):",
            "\t\t# koi ek true ho sakta hain ya dono bhi",
            "\t\tself._imply(self.negate(x),y)",
            "\t\tself._imply(self.negate(y),x)",
            "\tdef set(self, x):",
            "\t\tself._imply(self.negate(x),x)",
            "\tdef solve(self):",
            "\t\tSCC = find_SCC(self.graph)",
            "\t\torder = [0] * (2 * self.n)",
            "\t\tfor i, comp in enumerate(SCC):",
            "\t\t\tfor x in comp:",
            "\t\t\t\torder[x] = i",
            "\t\tfor i in range(self.n):",
            "\t\t\tif order[i] == order[self.negate(i)]:",
            "\t\t\t\treturn False, None",
            "\t\treturn True, [+(order[i] > order[self.negate(i)]) for i in range(self.n)]"
        ],
        "description": "2sat implementation"
    },
    "graphflatten": {
        "prefix": "graphflatten",
        "body": [
            "class UnionFind:",
            "\tdef __init__(self, n):",
            "\t\tself.parent = list(range(n))",
            "\tdef find(self, a):",
            "\t\tacopy = a",
            "\t\twhile a != self.parent[a]:",
            "\t\t\ta = self.parent[a]",
            "\t\twhile acopy != a:",
            "\t\t\tself.parent[acopy], acopy = a, self.parent[acopy]",
            "\t\treturn a",
            "\tdef merge(self, a, b):",
            "\t\tself.parent[self.find(b)] = self.find(a)",
            "",
            "def kruskal(edges,n=None):",
            "\tif not n:",
            "\t\tn = len(edges)+1",
            "\tedges = sorted(edges,key=lambda x:x[2])",
            "\tunion = UnionFind(n)",
            "\tans = []",
            "\tval = 0",
            "\tfor u,v,w in edges:",
            "\t\tt = union.find(u)",
            "\t\tt1 = union.find(v)",
            "\t\tif t!=t1:",
            "\t\t\tval += w",
            "\t\t\tunion.parent[t1] = t",
            "\t\t\tans.append((u,v,w))",
            "\treturn ans,val",
            "",
            "def dfs(graph):",
            "\tstarttime = [[0,0] for i in range(len(graph))]",
            "\ttime = 0",
            "\tstack = [(0,-1,0)]",
            "\twhile stack:",
            "\t\tcur, prev, state = stack.pop()",
            "\t\tif state == 0:",
            "\t\t\tstarttime[cur][0] = time",
            "\t\t\ttime += 1",
            "\t\t\tstack.append((cur, prev, 1))",
            "\t\t\tfor neighbor in graph[cur]:",
            "\t\t\t\tif neighbor == prev:",
            "\t\t\t\t\tcontinue",
            "\t\t\t\tstack.append((neighbor, cur, 0))",
            "\t\telif state == 1:",
            "\t\t\tstarttime[cur][1] = time",
            "\treturn starttime",
            "",
            "def is_bipartite(graph):",
            "\tn = len(graph)",
            "\tcolor = [-1] * n",
            "\tfor start in range(n):",
            "\t\tif color[start] == -1:",
            "\t\t\tcolor[start] = 0",
            "\t\t\tstack = [start]",
            "\t\t\twhile stack:",
            "\t\t\t\tparent = stack.pop()",
            "\t\t\t\tfor child in graph[parent]:",
            "\t\t\t\t\tif color[child] == -1:",
            "\t\t\t\t\t\tcolor[child] = 1 - color[parent]",
            "\t\t\t\t\t\tstack.append(child)",
            "\t\t\t\t\telif color[parent] == color[child]:",
            "\t\t\t\t\t\treturn False, color",
            "\treturn True, color"
        ],
        "description": "graphflatten implementation"
    },
    "Graphoth": {
        "prefix": "graphoth",
        "body": [
            "def euler_path(d):",
            "\tstart = [1]",
            "\tans = []",
            "\twhile start:",
            "\t\tcur = start[-1]",
            "\t\tif len(d[cur])==0:",
            "\t\t\tans.append(start.pop())",
            "\t\t\tcontinue",
            "\t\tk1 = d[cur].pop()",
            "\t\td[k1].remove(cur) # if undirected",
            "\t\tstart.append(k1)",
            "\treturn ans",
            "",
            "def floyd_warshall(n, edges):",
            "\tdist = [[0 if i == j else float(\"inf\") for i in range(n)] for j in range(n)]",
            "\tpred = [[None] * n for _ in range(n)]",
            "",
            "\tfor u, v, d in edges:",
            "\t\tdist[u][v] = d",
            "\t\tpred[u][v] = u",
            "",
            "\tfor k in range(n):",
            "\t\tfor i in range(n):",
            "\t\t\tfor j in range(n):",
            "\t\t\t\tif dist[i][k] + dist[k][j] < dist[i][j]:",
            "\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j]",
            "\t\t\t\t\tpred[i][j] = pred[k][j]",
            "\t# Sanity Check",
            "\t# for u, v, d in edges:",
            "\t#\t if dist[u] + d < dist[v]:",
            "\t#\t\t return None",
            "\treturn dist, pred",
            "",
            "def bellman_ford(n, edges, start=0):",
            "\tdist = [float(\"inf\")] * n",
            "\tpred = [None] * n",
            "\tdist[start] = 0",
            "\tfor _ in range(n):",
            "\t\tfor u, v, d in edges:",
            "\t\t\tif dist[u] + d < dist[v]:",
            "\t\t\t\tdist[v] = dist[u] + d",
            "\t\t\t\tpred[v] = u",
            "\t# for u, v, d in edges:",
            "\t#\t if dist[u] + d < dist[v]:",
            "\t#\t\t return -1",
            "\t# This returns -1 , if there is a negative cycle",
            "\treturn dist",
            "",
            "def toposort(graph):",
            "\tres, found = [], [0] * len(graph)",
            "\tstack = list(range(len(graph)))",
            "\twhile stack:",
            "\t\tnode = stack.pop()",
            "\t\tif node < 0:",
            "\t\t\tres.append(~node)",
            "\t\telif not found[node]:",
            "\t\t\tfound[node] = 1",
            "\t\t\tstack.append(~node)",
            "\t\t\tstack += graph[node]",
            "\tfor node in res:",
            "\t\tif any(found[nei] for nei in graph[node]):",
            "\t\t\treturn None",
            "\t\tfound[node] = 0",
            "\treturn res[::-1]"
        ],
        "description": "Graphoth implementation"
    },
    "graph": {
        "prefix": "graph",
        "body": [
            "def bfsf(d,start=0):",
            "\tbfs = [start]",
            "\tvisited = [False]*(len(d))",
            "\tvisited[start] = True",
            "\tfor u in bfs:",
            "\t\tfor j in d[u]:",
            "\t\t\tif visited[j]:",
            "\t\t\t\tcontinue",
            "\t\t\tvisited[j] = True",
            "\t\t\tbfs.append(j)",
            "\treturn bfs",
            "",
            "def dfs(d,start=0):",
            "\t# I can also use this to replicate recursion",
            "\t# without facing the overhead",
            "\tn = len(d)",
            "\tvisited = [False]*n",
            "\tdp = [0]*n",
            "\tfinished = [False]*n",
            "\tstack = [start]",
            "\twhile stack:",
            "\t\tstart = stack[-1]",
            "\t\t# stack.pop() # use this if there is nothing after returning",
            "\t\tif not visited[start]:",
            "\t\t\tvisited[start] = True",
            "\t\t\tfor child in d[start]:",
            "\t\t\t\tif not visited[child]:",
            "\t\t\t\t\tstack.append(child)",
            "\t\telse:",
            "\t\t\tstack.pop()",
            "\t\t\tdp[start] += 1",
            "\t\t\tfor child in d[start]:",
            "\t\t\t\tif finished[child]:",
            "\t\t\t\t\tdp[start] += dp[child]",
            "\t\t\tfinished[start] = True",
            "\t\t\t# remove else if you are doing nothing here",
            "\t\t\t# add the stuff that you do post traversel here",
            "\t\t\t# and add the finished array",
            "\treturn dp",
            "",
            "def dijkstra(d,start=0):",
            "\tn = len(d)",
            "\tdist = [float(\"inf\")]*n",
            "\t# parents = [-1]*n",
            "\tdist[start] = 0",
            "\tqueue = [(0, start)]",
            "\twhile queue:",
            "\t\tpath_len, v = heappop(queue)",
            "\t\tif path_len == dist[v]:",
            "\t\t\tfor w, edge_len in d[v]:",
            "\t\t\t\tnew_dist = edge_len+path_len",
            "\t\t\t\tif new_dist<dist[w]:",
            "\t\t\t\t\tdist[w] = new_dist",
            "\t\t\t\t\t# parents[w] = v",
            "\t\t\t\t\theappush(queue, (new_dist, w))",
            "\treturn dist"
        ],
        "description": "graph implementation"
    },
    "dfsin": {
        "prefix": "dfsin",
        "body": [
            "n = len(gr)",
            "visited = [False]*n",
            "finished = [False]*n",
            "stack = [0]",
            "while stack:",
            "\tstart = stack[-1]",
            "\tif not visited[start]:",
            "\t\tvisited[start] = True",
            "\t\tfor child in gr[start]:",
            "\t\t\tif not visited[child]:",
            "\t\t\t\tstack.append(child)",
            "\telse:",
            "\t\tstack.pop()",
            "\t\tfor child in gr[start]:",
            "\t\t\tif finished[child]:",
            "\t\t\t\t# perform the post rec operations here",
            "\t\t\t\tpass",
            "\t\tfinished[start] = True"
        ],
        "description": "dfsin implementation"
    },
    "utils": {
        "prefix": "utils",
        "body": [
            "def extras():",
            "\tgetcontext().prec = 50",
            "\tsys.setrecursionlimit(10**6)",
            "\tsys.set_int_max_str_digits(10**5)",
            "# extras()",
            "",
            "def interactive():",
            "\timport builtins",
            "\t# print(globals())",
            "\tglobals()['print'] = lambda *args, **kwargs: builtins.print(*args, flush=True, **kwargs)",
            "# interactive()",
            "",
            "def GI(n,m=None,sub=-1,dirs=False,weight=False):",
            "\tif m==None:",
            "\t\tm = n-1",
            "\td = [[] for i in range(n)]",
            "\tif not weight:",
            "\t\tfor i in range(m):",
            "\t\t\tu,v = LII_C(lambda x:int(x)+sub)",
            "\t\t\td[u].append(v)",
            "\t\t\tif not dirs:",
            "\t\t\t\td[v].append(u)",
            "\telse:",
            "\t\tfor i in range(m):",
            "\t\t\tu,v,w = LII()",
            "\t\t\td[u+sub].append((v+sub,w))",
            "\t\t\tif not dirs:",
            "\t\t\t\td[v+sub].append((u+sub,w))",
            "\treturn d",
            "",
            "ordalp = lambda s : ord(s)-65 if s.isupper() else ord(s)-97",
            "alp = lambda x : chr(97+x)",
            "yes = lambda : print(\"Yes\")",
            "no = lambda : print(\"No\")",
            "yn = lambda flag : print(\"Yes\" if flag else \"No\")",
            "printf = lambda x : print(-1 if x==float('inf') else x)",
            "lalp = 'abcdefghijklmnopqrstuvwxyz'",
            "ualp = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'",
            "dirs = ((1,0),(0,1),(-1,0),(0,-1))",
            "dirs8 = ((1,0),(0,1),(-1,0),(0,-1),(1,-1),(-1,1),(1,1),(-1,-1))",
            "ldir = {'D':(1,0),'U':(-1,0),'R':(0,1),'L':(0,-1)}"
        ],
        "description": "utils implementation"
    },
    "perdsu": {
        "prefix": "perdsu",
        "body": [
            "class Node:",
            "\tdef __init__(self,left=None,right=None,parent=0,size=1):",
            "\t\tself.left = left",
            "\t\tself.right = right",
            "\t\tself.parent = parent",
            "\t\tself.size = size",
            "class PersistentDSU:",
            "\tdef __init__(self,n):",
            "\t\tself.n = n",
            "\t\tself.versions = [self._build(0,n)]",
            "\tdef _build(self,l,r):",
            "\t\tif r-l==1:",
            "\t\t\treturn Node(parent=l,size=1)",
            "\t\tmid=(l+r)//2",
            "\t\treturn Node(self._build(l,mid),self._build(mid,r))",
            "\tdef _get(self,node,l,r,idx):",
            "\t\tif r-l==1:",
            "\t\t\treturn node.parent,node.size",
            "\t\tmid=(l+r)//2",
            "\t\tif idx<mid:",
            "\t\t\treturn self._get(node.left,l,mid,idx)",
            "\t\treturn self._get(node.right,mid,r,idx)",
            "\tdef _update(self,node,l,r,idx,parent=None,size=None):",
            "\t\tif r-l==1:",
            "\t\t\treturn Node(parent if parent is not None else node.parent,size if size is not None else node.size)",
            "\t\tmid=(l+r)//2",
            "\t\tif idx<mid:",
            "\t\t\treturn Node(self._update(node.left,l,mid,idx,parent,size),node.right)",
            "\t\treturn Node(node.left,self._update(node.right,mid,r,idx,parent,size))",
            "\tdef find(self,root,node):",
            "\t\tparent,_ = self._get(root,0,self.n,node)",
            "\t\treturn node if parent==node else self.find(root,parent)",
            "\tdef union(self,version,u,v):",
            "\t\troot=self.versions[version]",
            "\t\tu=self.find(root,u)",
            "\t\tv=self.find(root,v)",
            "\t\tif u==v:",
            "\t\t\tself.versions.append(root)",
            "\t\t\treturn len(self.versions)-1",
            "\t\t_,size_u=self._get(root,0,self.n,u)",
            "\t\t_,size_v=self._get(root,0,self.n,v)",
            "\t\tif size_u>size_v:",
            "\t\t\tu,v=v,u",
            "\t\troot=self._update(root,0,self.n,u,parent=v)",
            "\t\troot=self._update(root,0,self.n,v,size=size_u+size_v)",
            "\t\tself.versions.append(root)",
            "\t\treturn len(self.versions)-1"
        ],
        "description": "perdsu implementation"
    },
    "Merge Sort Tree": {
        "prefix": "sorttree",
        "body": [
            "class MergeSortTree:",
            "\tdef merge(L,L1):",
            "\t\tL2 = []",
            "\t\tL = list(L);L1 = list(L1)",
            "\t\ti = j = 0",
            "\t\twhile j<len(L) and i<len(L1):",
            "\t\t\tif L[j]<L1[i]:",
            "\t\t\t\tL2.append(L[j])",
            "\t\t\t\tj += 1",
            "\t\t\telse:",
            "\t\t\t\tL2.append(L1[i])",
            "\t\t\t\ti += 1",
            "\t\tL2.extend(L[j:]+L1[i:])",
            "\t\treturn L2",
            "\tdef __init__(self, data):",
            "\t\tself.n = len(data)",
            "\t\tself.tree = [SortedList() for _ in range(2 * self.n)]",
            "\t\tself.build(data)",
            "\tdef build(self, data):",
            "\t\tfor i in range(self.n):",
            "\t\t\tself.tree[self.n + i].insert(data[i])",
            "\t\tfor i in range(self.n - 1, 0, -1):",
            "\t\t\tself.tree[i] = SortedList(MergeSortTree.merge(self.tree[i << 1],self.tree[i<<1|1]))",
            "\tdef query(self, left, right,l,r):",
            "\t\tres = 0",
            "\t\tleft += self.n",
            "\t\tright += self.n",
            "\t\twhile left < right:",
            "\t\t\tif left & 1:",
            "\t\t\t\tres += self.func(self.tree[left], l, r);left += 1",
            "\t\t\tif right & 1:",
            "\t\t\t\tright -= 1;res += self.func(self.tree[right], l, r)",
            "\t\t\tleft >>= 1;right >>= 1",
            "\t\treturn res",
            "\tdef func(self, L, l, r):",
            "\t\treturn L.bisect_right(r)-L.bisect_left(l)",
            "\tdef update(self,pos,value):",
            "\t\tpos += self.n;old_val = self.tree[pos][0]",
            "\t\tself.tree[pos].remove(old_val)",
            "\t\tself.tree[pos].add(value)",
            "\t\twhile pos:",
            "\t\t\tpos >>= 1",
            "\t\t\tself.tree[pos].remove(old_val)",
            "\t\t\tself.tree[pos].add(value)"
        ],
        "description": "sorttree implementation"
    },
    "2DBIT": {
        "prefix": "2dbit",
        "body": [
            "class BIT2D:",
            "\tdef __init__(self, arr):",
            "\t\tself.n = len(arr)",
            "\t\tself.m = len(arr[0]) if self.n > 0 else 0",
            "\t\t# self.bit = [row[:] for row in arr]",
            "\t\tself.bit = arr # assuming that arr is not used after this",
            "\t\tfor i in range(self.n):",
            "\t\t\tfor j in range(self.m):",
            "\t\t\t\tni = i | (i + 1)",
            "\t\t\t\tif ni < self.n:",
            "\t\t\t\t\tself.bit[ni][j] += self.bit[i][j]",
            "\t\tfor i in range(self.n):",
            "\t\t\tfor j in range(self.m):",
            "\t\t\t\tnj = j | (j + 1)",
            "\t\t\t\tif nj < self.m:",
            "\t\t\t\t\tself.bit[i][nj] += self.bit[i][j]",
            "\tdef add(self, x, y, delta):",
            "\t\t# 0-based in log n * log m",
            "\t\ti = x",
            "\t\twhile i < self.n:",
            "\t\t\tj = y",
            "\t\t\twhile j < self.m:",
            "\t\t\t\tself.bit[i][j] += delta",
            "\t\t\t\tj |= j + 1",
            "\t\t\ti |= i + 1",
            "\tdef sum(self, x, y):",
            "\t\t# sum from 0,0 to x,y inclusive in log n * log m",
            "\t\tif not (0<=x<self.n) or not (0<=y<self.m):",
            "\t\t\treturn 0",
            "\t\tres = 0",
            "\t\ti = x",
            "\t\twhile i >= 0:",
            "\t\t\tj = y",
            "\t\t\twhile j >= 0:",
            "\t\t\t\tres += self.bit[i][j]",
            "\t\t\t\tj = (j & (j + 1)) - 1",
            "\t\t\ti = (i & (i + 1)) - 1",
            "\t\treturn res",
            "\tdef query(self, x1, y1, x2, y2):",
            "\t\t# sum of L[x1:x2+1][y1:y2+1]",
            "\t\treturn (self.sum(x2,y2)-self.sum(x1-1,y2)-self.sum(x2,y1-1)+(self.sum(x1-1,y1-1)))"
        ],
        "description": "2DBIT implementation"
    },
    "mono": {
        "prefix": "mono",
        "body": [
            "from typing import Callable, TypeVar, Generic, List",
            "T = TypeVar('T')",
            "class MonoStack(Generic[T]):",
            "\tdef __init__(self, op: Callable[[T, T], T], e: Callable[[], T]):",
            "\t\tself.s: List[T] = []",
            "\t\tself.sMono: List[T] = []",
            "\t\tself.op = op",
            "\t\tself.e = e",
            "\tdef push(self, x: T):",
            "\t\tself.s.append(x)",
            "\t\tif not self.sMono:",
            "\t\t\tself.sMono.append(x)",
            "\t\telse:",
            "\t\t\tself.sMono.append(self.op(self.sMono[-1], x))",
            "\tdef pop(self) -> T:",
            "\t\tif not self.s:",
            "\t\t\treturn self.e()",
            "\t\tself.sMono.pop()",
            "\t\treturn self.s.pop()",
            "\tdef get(self) -> T:",
            "\t\treturn self.sMono[-1] if self.sMono else self.e()",
            "\tdef empty(self) -> bool:",
            "\t\treturn not self.s",
            "",
            "class MonoDeque(Generic[T]):",
            "\tdef __init__(self, op: Callable[[T, T], T] = lambda a,b: max(a,b), e: Callable[[], T] = lambda : -float('inf')):",
            "\t\t# e is the unit value in form of lambda : 0",
            "\t\t# The Function op must be associative, f(a,b)==f(b,a)",
            "\t\tself.op = op",
            "\t\tself.e = e",
            "\t\tself.front = MonoStack(op, e)",
            "\t\tself.back = MonoStack(op, e)",
            "\tdef push_back(self, x: T):",
            "\t\tself.back.push(x)",
            "\tdef pop_front(self):",
            "\t\tif self.front.empty():",
            "\t\t\twhile not self.back.empty():",
            "\t\t\t\tself.front.push(self.back.pop())",
            "\t\tself.front.pop()",
            "\tdef get(self) -> T:",
            "\t\t# returns the function op of the elements present in the deque",
            "\t\treturn self.op(self.front.get(), self.back.get())"
        ],
        "description": "mono implementation"
    },
    
    "SAutomaton": {
        "prefix": "sautomaton",
        "body": [
            "class State:",
            "\tdef __init__(self):",
            "\t\tself.next = {}",
            "\t\tself.link = -1",
            "\t\tself.len = 0",
            "\t\tself.first_pos = -1",
            "\t\tself.occurrence = 0",
            "",
            "class SuffixAutomaton:",
            "\tdef __init__(self, s):",
            "\t\tself.s = s",
            "\t\tself.states = [State()]",
            "\t\tself.size = 1",
            "\t\tself.last = 0",
            "\t\tfor ch in s:",
            "\t\t\tself.add(ch)",
            "\t\tself._prepare_occurrences() # comment out if taking time",
            "\t\tself._count_substrings()",
            "\tdef add(self, ch):",
            "\t\tp = self.last",
            "\t\tcur = self.size",
            "\t\tself.states.append(State())",
            "\t\tself.size += 1",
            "\t\tself.states[cur].len = self.states[p].len + 1",
            "\t\tself.states[cur].first_pos = self.states[cur].len - 1",
            "\t\tself.states[cur].occurrence = 1",
            "\t\twhile p != -1 and ch not in self.states[p].next:",
            "\t\t\tself.states[p].next[ch] = cur",
            "\t\t\tp = self.states[p].link",
            "\t\tif p == -1:",
            "\t\t\tself.states[cur].link = 0",
            "\t\telse:",
            "\t\t\tq = self.states[p].next[ch]",
            "\t\t\tif self.states[p].len + 1 == self.states[q].len:",
            "\t\t\t\tself.states[cur].link = q",
            "\t\t\telse:",
            "\t\t\t\tclone = self.size",
            "\t\t\t\tself.states.append(State())",
            "\t\t\t\tself.size += 1",
            "\t\t\t\tself.states[clone].len = self.states[p].len + 1",
            "\t\t\t\tself.states[clone].next = self.states[q].next.copy()",
            "\t\t\t\tself.states[clone].link = self.states[q].link",
            "\t\t\t\tself.states[clone].first_pos = self.states[q].first_pos",
            "\t\t\t\twhile p != -1 and self.states[p].next[ch] == q:",
            "\t\t\t\t\tself.states[p].next[ch] = clone",
            "\t\t\t\t\tp = self.states[p].link",
            "\t\t\t\tself.states[q].link = self.states[cur].link = clone",
            "\t\tself.last = cur",
            "\tdef _prepare_occurrences(self):",
            "\t\torder = sorted(range(self.size), key=lambda x: -self.states[x].len)",
            "\t\tfor i in order:",
            "\t\t\tif self.states[i].link != -1:",
            "\t\t\t\tself.states[self.states[i].link].occurrence += self.states[i].occurrence",
            "\tdef _count_substrings(self):",
            "\t\tself.dp = [0] * self.size",
            "\t\tfor i in range(self.size):",
            "\t\t\tself.dp[i] = 1",
            "\t\torder = sorted(range(self.size), key=lambda x: self.states[x].len)",
            "\t\tfor u in reversed(order):",
            "\t\t\tfor v in self.states[u].next.values():",
            "\t\t\t\tself.dp[u] += self.dp[v]",
            "\tdef is_substring(self, s):",
            "\t\tcurrent = 0",
            "\t\tfor ch in s:",
            "\t\t\tif ch not in self.states[current].next:",
            "\t\t\t\treturn False",
            "\t\t\tcurrent = self.states[current].next[ch]",
            "\t\treturn True",
            "\tdef count_occurrences(self, s):",
            "\t\tcurrent = 0",
            "\t\tfor ch in s:",
            "\t\t\tif ch not in self.states[current].next:",
            "\t\t\t\treturn 0",
            "\t\t\tcurrent = self.states[current].next[ch]",
            "\t\treturn self.states[current].occurrence",
            "\tdef count_distinct_substrings(self):",
            "\t\treturn sum(self.states[i].len - self.states[self.states[i].link].len for i in range(1, self.size))",
            "\tdef kth_lex_substring(self, k):",
            "\t\t# kth distinct substring",
            "\t\tresult = []",
            "\t\tcurrent = 0",
            "\t\twhile k:",
            "\t\t\tfor ch in sorted(self.states[current].next):",
            "\t\t\t\tnext_state = self.states[current].next[ch]",
            "\t\t\t\tif self.dp[next_state] < k:",
            "\t\t\t\t\tk -= self.dp[next_state]",
            "\t\t\t\telse:",
            "\t\t\t\t\tresult.append(ch)",
            "\t\t\t\t\tk -= 1",
            "\t\t\t\t\tcurrent = next_state",
            "\t\t\t\t\tbreak",
            "\t\treturn ''.join(result)",
            "\tdef enumerate_all_substrings(self):",
            "\t\tresult = []",
            "\t\tdef dfs(state, path):",
            "\t\t\tfor ch in sorted(self.states[state].next):",
            "\t\t\t\tnext_state = self.states[state].next[ch]",
            "\t\t\t\tresult.append(path + ch)",
            "\t\t\t\tdfs(next_state, path + ch)",
            "\t\tdfs(0, \"\")",
            "\t\treturn result",
            "\tdef longest_common_substring(self, t):",
            "\t\tv = 0;l = 0;best = 0;bestpos = 0",
            "\t\tfor i in range(len(t)):",
            "\t\t\twhile v and t[i] not in self.states[v].next:",
            "\t\t\t\tv = self.states[v].link",
            "\t\t\t\tl = self.states[v].len",
            "\t\t\tif t[i] in self.states[v].next:",
            "\t\t\t\tv = self.states[v].next[t[i]]",
            "\t\t\t\tl += 1",
            "\t\t\tif l > best:",
            "\t\t\t\tbest = l",
            "\t\t\t\tbestpos = i",
            "\t\treturn t[bestpos - best + 1:bestpos + 1]",
            "\tdef all_occurrences(self, s):",
            "\t\tcurrent = 0",
            "\t\tfor ch in s:",
            "\t\t\tif ch not in self.states[current].next:",
            "\t\t\t\treturn []",
            "\t\t\tcurrent = self.states[current].next[ch]",
            "\t\tpositions = []",
            "\t\tdef collect(state):",
            "\t\t\tif self.states[state].occurrence:",
            "\t\t\t\tpos = self.states[state].first_pos - len(s) + 1",
            "\t\t\t\tpositions.append(pos)",
            "\t\t\tfor v in self.states[state].next.values():",
            "\t\t\t\tcollect(v)",
            "\t\tcollect(current)",
            "\t\treturn sorted(set(positions))",
            "\tdef missing_sub(self):",
            "\t\tvisited = set()",
            "\t\tq = deque([(0, \"\")])",
            "\t\twhile q:",
            "\t\t\tstate, path = q.popleft()",
            "\t\t\tfor c in map(chr, range(97, 123)):",
            "\t\t\t\tif c not in self.states[state].next:",
            "\t\t\t\t\treturn path + c",
            "\t\t\t\tnext_state = self.states[state].next[c]",
            "\t\t\t\tif (next_state, path + c) not in visited:",
            "\t\t\t\t\tvisited.add((next_state, path + c))",
            "\t\t\t\t\tq.append((next_state, path + c))",
            "\t\treturn None"
        ],
        "description": "SAutomaton implementation"
    },
    "linalg": {
        "prefix": "linalg",
        "body": [
            "def solve_quadratic(a, b, c):",
            "\tif a == 0:return None",
            "\tD = b*b - 4*a*c",
            "\tif D < 0:return None",
            "\ts = math.isqrt(D)",
            "\tif s*s != D:return None",
            "\tden = 2*a",
            "\tif den == 0:return None",
            "\tx1, r1 = divmod(-b + s, den)",
            "\tx2, r2 = divmod(-b - s, den)",
            "\tif r1!=0 or r2!=0:return None",
            "\treturn (x1, x2)",
            "",
            "def solve_cubic(a, b, c, d):",
            "\tif a == 0:return None",
            "\troots = []",
            "\tfor x in range(-math.isqrt(abs(d)) - 1, math.isqrt(abs(d)) + 2):",
            "\t\tif a*x*x*x + b*x*x + c*x + d == 0:",
            "\t\t\troots.append(x)",
            "\treturn tuple(roots) if roots else None",
            "",
            "class XorBasis:",
            "\tdef __init__(self,A=[]):",
            "\t\tself.reduced_base = {}",
            "\t\tself.how = {}",
            "\t\tself.base = []",
            "\t\tfor i in A:",
            "\t\t\tself.add(i)",
            "\tdef max(self):",
            "\t\tbase = self.base; reduced_base = self.reduced_base",
            "\t\thow = self.how",
            "\t\tx = 0;tmp = 0",
            "\t\tfor j in sorted(reduced_base, reverse=True):",
            "\t\t\tif not x & (1 << j):",
            "\t\t\t\tx ^= reduced_base[j]",
            "\t\t\t\ttmp ^= how[j]",
            "\t\t# xor of these elements return the max element",
            "\t\treturn [base[j] for j in range(len(base)) if tmp & (1 << j)]",
            "\tdef make(self,k):",
            "\t\t# returns True if can make x with these elements",
            "\t\treduced_base = self.reduced_base",
            "\t\tfor j in range(k.bit_length()-1,-1,-1):",
            "\t\t\tif ((1<<j)&k):",
            "\t\t\t\tif j in reduced_base:",
            "\t\t\t\t\tk ^= reduced_base[j]",
            "\t\t\t\telse:",
            "\t\t\t\t\treturn False",
            "\t\treturn k==0",
            "\tdef add(self,a):",
            "\t\t# adds a to the basis",
            "\t\treduced_base = self.reduced_base",
            "\t\thow = self.how;base = self.base",
            "\t\ttmp = 0",
            "\t\twhile a:",
            "\t\t\tb = a.bit_length() - 1",
            "\t\t\tif b in reduced_base:",
            "\t\t\t\ta ^= reduced_base[b]",
            "\t\t\t\ttmp ^= how[b]",
            "\t\t\telse:",
            "\t\t\t\treduced_base[b] = a",
            "\t\t\t\thow[b] = tmp | (1 << len(base))",
            "\t\t\t\tbase.append(a)",
            "\t\t\t\tbreak",
            "",
            "def simplex_bland(c, A, b, frac=False):",
            "\t# maximize ci.xi",
            "\t# given ai.xi <= bi and xi >= 0",
            "\tif not frac:",
            "\t\tn = len(c)",
            "\t\tm = len(b)",
            "\t\tT = [A[i] + [0]*i + [1] + [0]*(m-i-1) + [b[i]] for i in range(m)]",
            "\t\tT.append([-ci for ci in c] + [0]*m + [0])",
            "\t\tN = list(range(n)) # non-basic",
            "\t\tB = list(range(n, n+m)) # basic",
            "\t\tdef pivot(r, s):",
            "\t\t\t# Make coeffecient of pivot row 1 and Eliminate column s in all other rows",
            "\t\t\tT[r] = [v / T[r][s] for v in T[r]]",
            "\t\t\tfor i in range(len(T)):",
            "\t\t\t\tif i != r:",
            "\t\t\t\t\tfac = T[i][s]",
            "\t\t\t\t\tT[i] = [T[i][j] - fac * T[r][j] for j in range(len(T[0]))]",
            "\t\twhile True:",
            "\t\t\ts = None",
            "\t\t\tfor j in range(len(T[0]) - 1):",
            "\t\t\t\tif T[-1][j] < 0:",
            "\t\t\t\t\ts = j",
            "\t\t\t\t\tbreak",
            "\t\t\tif s is None:",
            "\t\t\t\tbreak",
            "\t\t\t# leaving row",
            "\t\t\tr = None",
            "\t\t\tfor i in range(m):",
            "\t\t\t\tif T[i][s] > 1e-12:",
            "\t\t\t\t\tratio = T[i][-1] / T[i][s]",
            "\t\t\t\t\tif r is None or ratio < T[r][-1] / T[r][s]:",
            "\t\t\t\t\t\tr = i",
            "\t\t\tif r is None:",
            "\t\t\t\treturn None",
            "\t\t\tpivot(r, s)",
            "\t\t\tB[r], N[s] = N[s], B[r]",
            "\t\tx = [0] * (n + m)",
            "\t\tfor i in range(m):",
            "\t\t\tx[B[i]] = T[i][-1]",
            "\t\treturn x[:n], T[-1][-1]",
            "\telse:",
            "\t\tfrom fractions import Fraction",
            "\t\tn = len(c)",
            "\t\tm = len(b)",
            "\t\tc = [Fraction(ci) for ci in c]",
            "\t\tA = [[Fraction(aij) for aij in row] for row in A]",
            "\t\tb = [Fraction(bi) for bi in b]",
            "\t\tT = [A[i] + [Fraction(1 if i == j else 0) for j in range(m)] + [b[i]]",
            "\t\t\t for i in range(m)]",
            "\t\tT.append([-ci for ci in c] + [Fraction(0)] * (m + 1))",
            "\t\tN = list(range(n))",
            "\t\tB = list(range(n, n+m))",
            "\t\tdef pivot(r, s):",
            "\t\t\tpiv = T[r][s]",
            "\t\t\tT[r] = [v / piv for v in T[r]]",
            "\t\t\tfor i in range(m + 1):",
            "\t\t\t\tif i != r:",
            "\t\t\t\t\tfac = T[i][s]",
            "\t\t\t\t\tT[i] = [T[i][j] - fac * T[r][j] for j in range(len(T[0]))]",
            "\t\twhile True:",
            "\t\t\ts = None",
            "\t\t\tfor j in range(len(T[0]) - 1):",
            "\t\t\t\tif T[-1][j] < 0:",
            "\t\t\t\t\ts = j",
            "\t\t\t\t\tbreak",
            "\t\t\tif s is None:",
            "\t\t\t\tbreak",
            "\t\t\tr = None",
            "\t\t\tfor i in range(m):",
            "\t\t\t\tif T[i][s] > 0:",
            "\t\t\t\t\tratio = T[i][-1] / T[i][s]",
            "\t\t\t\t\tif r is None or ratio < T[r][-1] / T[r][s]:",
            "\t\t\t\t\t\tr = i",
            "\t\t\tif r is None:",
            "\t\t\t\treturn None",
            "\t\t\tpivot(r, s)",
            "\t\t\tB[r], N[s] = N[s], B[r]",
            "\t\tx = [Fraction(0)] * (n + m)",
            "\t\tfor i in range(m):",
            "\t\t\tx[B[i]] = T[i][-1]",
            "\t\treturn x[:n], T[-1][-1]",
            "",
            "def s_lr(l,r,pow=1):",
            "\tif l>r:return 0",
            "\tif pow==1:return (r*(r+1)//2) - ((l-1)*l//2)",
            "\telif pow==2:return (r*(r+1)*(2*r+1)//6) - ((l-1)*l*(2*l-1)//6)",
            "\telif pow==3:return (r*(r+1)//2)**2 - ((l-1)*l//2)**2",
            "\telse:return None"
        ],
        "description": "linalg implementation"
    },
    "sqrt": {
        "prefix": "sqrt",
        "body": [
            "class SqrtDecomposition:",
            "\tdef __init__(self, arr, func= sum, default: int = 0):",
            "\t\tself.n = len(arr)",
            "\t\tself.a = list(arr)",
            "\t\tself.func = func",
            "\t\tself.default = default",
            "\t\tself.block_size = int(math.sqrt(self.n)) + 1",
            "\t\tself.blocks = [self.default] * self.block_size",
            "",
            "\t\tfor i in range(self.n):",
            "\t\t\tself.blocks[i // self.block_size] = self.func([self.blocks[i//self.block_size],self.a[i]])",
            "\tdef query(self, l: int, r: int) -> int:",
            "\t\t# from [L,R]",
            "\t\tres = self.default",
            "\t\ti = l",
            "\t\twhile i <= r:",
            "\t\t\tif i % self.block_size == 0 and i + self.block_size - 1 <= r:",
            "\t\t\t\tres = self.func([res, self.blocks[i // self.block_size]])",
            "\t\t\t\ti += self.block_size",
            "\t\t\telse:",
            "\t\t\t\tres = self.func([res, self.a[i]])",
            "\t\t\t\ti += 1",
            "\t\treturn res",
            "\tdef update(self, index: int, value: int):",
            "\t\tblock = index // self.block_size",
            "\t\tself.a[index] = value",
            "\t\tstart = block * self.block_size",
            "\t\tend = min(self.n, (block + 1) * self.block_size)",
            "\t\tself.blocks[block] = self.default",
            "\t\tfor i in range(start, end):",
            "\t\t\tself.blocks[block] = self.func([self.blocks[block], self.a[i]])"
        ],
        "description": "sqrt implementation"
    },
    "graph_dmgt": {
        "prefix": "graph_dmgt",
        "body": [
            "def find_bridges(adj):",
            "\t# returns all bridges",
            "\tbridges = []",
            "\tn = len(adj)",
            "\ttimer = 0",
            "\tvisited = [False]*n",
            "\ttin = [-1]*n",
            "\tlow = [-1]*n",
            "\tfor start in range(n):",
            "\t\tif visited[start]:",
            "\t\t\tcontinue",
            "\t\tstack = [(start, -1, 0, False)]",
            "\t\tvisited[start] = True",
            "\t\ttin[start] = low[start] = timer",
            "\t\ttimer += 1",
            "\t\twhile stack:",
            "\t\t\tv, parent, idx, backtrack = stack.pop()",
            "\t\t\tif backtrack:",
            "\t\t\t\tto = adj[v][idx]",
            "\t\t\t\tlow[v] = min(low[v], low[to])",
            "\t\t\t\tif low[to] > tin[v]:",
            "\t\t\t\t\tbridges.append((v,to))",
            "\t\t\t\tcontinue",
            "\t\t\tif idx < len(adj[v]):",
            "\t\t\t\tto = adj[v][idx]",
            "\t\t\t\tstack.append((v, parent, idx + 1, False))",
            "\t\t\t\tif to == parent:",
            "\t\t\t\t\tcontinue",
            "\t\t\t\tif visited[to]:",
            "\t\t\t\t\tlow[v] = min(low[v], tin[to])",
            "\t\t\t\telse:",
            "\t\t\t\t\tvisited[to] = True",
            "\t\t\t\t\ttin[to] = low[to] = timer",
            "\t\t\t\t\ttimer += 1",
            "\t\t\t\t\tstack.append((v, parent, idx, True))",
            "\t\t\t\t\tstack.append((to, v, 0, False))",
            "\treturn bridges",
            "",
            "def bridges_on_path(adj):",
            "\t# returns all bridges on path from 1 to n",
            "\tn = len(adj)",
            "\ttimer = 0",
            "\tvisited = [False]*n",
            "\ttin = [-1]*n",
            "\tlow = [-1]*n",
            "\tbridges = []",
            "\tfor start in range(n):",
            "\t\tif visited[start]:",
            "\t\t\tcontinue",
            "\t\tstack = [(start, -1, 0, False)]",
            "\t\tvisited[start] = True",
            "\t\ttin[start] = low[start] = timer",
            "\t\ttimer += 1",
            "\t\twhile stack:",
            "\t\t\tv, parent, idx, backtrack = stack.pop()",
            "\t\t\tif backtrack:",
            "\t\t\t\tto = adj[v][idx]",
            "\t\t\t\tlow[v] = min(low[v], low[to])",
            "\t\t\t\tif low[to] > tin[v]:",
            "\t\t\t\t\tbridges.append((v, to))",
            "\t\t\t\tcontinue",
            "\t\t\tif idx < len(adj[v]):",
            "\t\t\t\tto = adj[v][idx]",
            "\t\t\t\tstack.append((v, parent, idx+1, False))",
            "\t\t\t\tif to == parent:",
            "\t\t\t\t\tcontinue",
            "\t\t\t\tif visited[to]:",
            "\t\t\t\t\tlow[v] = min(low[v], tin[to])",
            "\t\t\t\telse:",
            "\t\t\t\t\tvisited[to] = True",
            "\t\t\t\t\ttin[to] = low[to] = timer",
            "\t\t\t\t\ttimer += 1",
            "\t\t\t\t\tstack.append((v, parent, idx, True))",
            "\t\t\t\t\tstack.append((to, v, 0, False))",
            "\tcomp_id = [-1]*n",
            "\tcomp = 0",
            "\tbridge_set = set(bridges)",
            "\tfor i in range(n):",
            "\t\tif comp_id[i] != -1:",
            "\t\t\tcontinue",
            "\t\tstack = [i]",
            "\t\tcomp_id[i] = comp",
            "\t\twhile stack:",
            "\t\t\tv = stack.pop()",
            "\t\t\tfor to in adj[v]:",
            "\t\t\t\tif comp_id[to] == -1 and (v, to) not in bridge_set and (to, v) not in bridge_set:",
            "\t\t\t\t\tcomp_id[to] = comp",
            "\t\t\t\t\tstack.append(to)",
            "\t\tcomp += 1",
            "",
            "\ttree = [[] for _ in range(comp)]",
            "\tfor u, v in bridges:",
            "\t\tcu, cv = comp_id[u], comp_id[v]",
            "\t\ttree[cu].append((cv, (u, v)))",
            "\t\ttree[cv].append((cu, (u, v)))",
            "",
            "\tc1, cN = comp_id[0], comp_id[n-1]",
            "\tif c1 == cN:",
            "\t\treturn []",
            "\tparent = {c1: None}",
            "\tedge_used = {c1: None}",
            "\tstack = [c1]",
            "\twhile stack:",
            "\t\tu = stack.pop()",
            "\t\tfor v, e in tree[u]:",
            "\t\t\tif v not in parent:",
            "\t\t\t\tparent[v] = u",
            "\t\t\t\tedge_used[v] = e",
            "\t\t\t\tstack.append(v)",
            "\tpath_bridges = []",
            "\tcur = cN",
            "\twhile cur != c1:",
            "\t\tpath_bridges.append(edge_used[cur])",
            "\t\tcur = parent[cur]",
            "\treturn [(u,v) for u, v in path_bridges]",
            "",
            "def lowlink(edge):",
            "\tn = len(edge)",
            "\tparent = [-1] * n",
            "\tvisited = [False] * n",
            "\tfor s in range(n):",
            "\t\tif not visited[s]:",
            "\t\t\tque = [s]",
            "\t\t\twhile que:",
            "\t\t\t\tnow = que.pop()",
            "\t\t\t\tif visited[now]: continue",
            "\t\t\t\tvisited[now] = True",
            "\t\t\t\tfor nxt in edge[now]:",
            "\t\t\t\t\tif not visited[nxt]:",
            "\t\t\t\t\t\tparent[nxt] = now",
            "\t\t\t\t\t\tque.append(nxt)",
            "\torder = [-1] * n",
            "\tlow = [-1] * n",
            "\tis_articulation = [False] * n",
            "\tarticulation = []",
            "\tbridge = []",
            "\tdef dfs(s):",
            "\t\tidx = 0",
            "\t\tcnt = 0",
            "\t\tque = [~s,s]",
            "\t\twhile que:",
            "\t\t\tnow = que.pop()",
            "\t\t\tif now >= 0:",
            "\t\t\t\torder[now] = low[now] = idx",
            "\t\t\t\tidx += 1",
            "\t\t\t\tfor nxt in edge[now]:",
            "\t\t\t\t\tif parent[nxt] == now:",
            "\t\t\t\t\t\tque.append(~nxt)",
            "\t\t\t\t\t\tque.append(nxt)",
            "\t\t\t\t\telif parent[now] != nxt and order[nxt] != -1:",
            "\t\t\t\t\t\tlow[now] = min(low[now], order[nxt])",
            "\t\t\telse:",
            "\t\t\t\tnow = ~now",
            "\t\t\t\tpar = parent[now]",
            "\t\t\t\tif par == s: cnt += 1",
            "\t\t\t\tif now == s:",
            "\t\t\t\t\tis_articulation[now] |= (cnt >= 2)",
            "\t\t\t\t\tif is_articulation[now]:",
            "\t\t\t\t\t\tarticulation.append(now)",
            "\t\t\t\t\treturn",
            "\t\t\t\tif is_articulation[now]:",
            "\t\t\t\t\tarticulation.append(now)",
            "\t\t\t\tif now != parent[par]:",
            "\t\t\t\t\tlow[par] = min(low[par], low[now])",
            "\t\t\t\tis_articulation[par] |= (par != s) and (order[par] <= low[now])",
            "\t\t\t\tif order[par] < low[now]:",
            "\t\t\t\t\tbridge.append((par, now))",
            "\tfor i in range(n):",
            "\t\tif parent[i] == -1:",
            "\t\t\tdfs(i)",
            "\treturn articulation, bridge",
            "",
            "def find_2ecc(edges,d):",
            "\t# returns a new graph, in which two nodes are connected",
            "\t# if and only if they are part of same cycle.",
            "\t_,bridges = lowlink(d)",
            "\tnewd = [[] for i in range(len(d))]",
            "\tbridges = set((w(i[0]),w(i[1])) for i in bridges)",
            "\tfor u,v in edges:",
            "\t\tif (w(u),w(v)) not in bridges and (w(v),w(u)) not in bridges:",
            "\t\t\tnewd[u].append(v)",
            "\t\t\tnewd[v].append(u)",
            "\treturn newd"
        ],
        "description": "graph_dmgt implementation"
    },
    
    "fwht": {
        "prefix": "fwht",
        "body": [
            "def fwht(a, invert=False):",
            "\t# In-place Fast Walsh\u2013Hadamard Transform for XOR convolution.",
            "\t# invert: if True, computes inverse transform",
            "\tn = len(a);step = 1",
            "\twhile step<n:",
            "\t\tfor i in range(0,n,step*2):",
            "\t\t\tfor j in range(step):",
            "\t\t\t\ta[i+j],a[i+j+step] = a[i+j]+a[i+j+step],a[i+j]-a[i+j+step]",
            "\t\tstep *= 2",
            "\tif invert:",
            "\t\tfor i in range(n):",
            "\t\t\ta[i] //= n",
            "",
            "def fwt_or(a, invert=False):",
            "\tn = len(a);step = 1",
            "\twhile step<n:",
            "\t\tfor i in range(0,n,step*2):",
            "\t\t\tfor j in range(step):",
            "\t\t\t\tu = a[i+j]",
            "\t\t\t\tv = a[i+j+step]",
            "\t\t\t\tif not invert:",
            "\t\t\t\t\ta[i+j+step] = u+v",
            "\t\t\t\telse:",
            "\t\t\t\t\ta[i+j+step] = v-u",
            "\t\tstep *= 2",
            "",
            "def fwt_and(a, invert=False):",
            "\tn = len(a);step = 1",
            "\twhile step<n:",
            "\t\tfor i in range(0,n,step*2):",
            "\t\t\tfor j in range(step):",
            "\t\t\t\tu = a[i+j]",
            "\t\t\t\tv = a[i+j+step]",
            "\t\t\t\tif not invert:",
            "\t\t\t\t\ta[i+j] = u+v",
            "\t\t\t\telse:",
            "\t\t\t\t\ta[i+j] = u-v",
            "\t\tstep *= 2",
            "",
            "def convolution(A, B, fwt=fwht):",
            "\t# Computes XOR convolution of arrays A and B using FWHT",
            "\t# res[i] = summation of A[j]*B[k] such that j xor k = i",
            "\tn = 1;x = max(len(A),len(B))",
            "\twhile n<x:n <<= 1",
            "\tn <<= 1",
            "\tfa = A + [0] * (n - len(A))",
            "\tfb = B + [0] * (n - len(B))",
            "\tfwt(fa)",
            "\tfwt(fb)",
            "\tfor i in range(n):",
            "\t\tfa[i] *= fb[i]",
            "\tfwt(fa, invert=True)",
            "\treturn fa"
        ],
        "description": "fwht implementation"
    },
    
    "graph_decom": {
        "prefix": "graph_decom",
        "body": [
            "def shallowest_decomposition_tree(graph, root=0):",
            "\t# returns a root and a directed tree, iterate on it and you",
            "\t# will find the new centroid",
            "\t# slightly faster than centroid_decomposition_tree",
            "\tctz = lambda x:(x & -x).bit_length()-1",
            "\tn = len(graph)",
            "\tforbidden = [0] * n",
            "\tdecomposition_tree = [[] for _ in range(n)]",
            "\tstacks = [[] for _ in range(n.bit_length())]",
            "\tdef extract_chain(labels, u):",
            "\t\twhile labels:",
            "\t\t\tlabel = labels.bit_length() - 1",
            "\t\t\tlabels ^= 2**label",
            "\t\t\tv = stacks[label].pop()",
            "\t\t\tdecomposition_tree[u].append(v)",
            "\t\t\tu = v",
            "\tdfs = [root]",
            "\twhile dfs:",
            "\t\tu = dfs.pop()",
            "\t\tif u >= 0:",
            "\t\t\tforbidden[u] = -1",
            "\t\t\tdfs.append(~u)",
            "\t\t\tfor v in graph[u]:",
            "\t\t\t\tif not forbidden[v]:",
            "\t\t\t\t\tdfs.append(v)",
            "\t\telse:",
            "\t\t\tu = ~u",
            "\t\t\tforbidden_once = forbidden_twice = 0",
            "\t\t\tfor v in graph[u]:",
            "\t\t\t\tforbidden_twice  |= forbidden_once & (forbidden[v] + 1)",
            "\t\t\t\tforbidden_once  |= forbidden[v] + 1",
            "\t\t\tforbidden[u] = forbidden_once | (2**forbidden_twice.bit_length() - 1)",
            "\t\t\tlabel_u = ctz(forbidden[u] + 1)",
            "\t\t\tstacks[label_u].append(u)",
            "\t\t\tfor v in graph[u]:",
            "\t\t\t\textract_chain((forbidden[v] + 1) & (2**label_u - 1), u)",
            "\tmax_label = (forbidden[root] + 1).bit_length() - 1",
            "\tdecomposition_root = stacks[max_label].pop()",
            "\textract_chain((forbidden[root] + 1) & (2**max_label - 1), decomposition_root)",
            "\treturn decomposition_tree, decomposition_root",
            "",
            "def centroid_decomposition_tree(graph):",
            "\t# returns a root and a directed tree, iterate on it and you",
            "\t# will find the new centroid",
            "\tn = len(graph)",
            "\tgraph = [c[:] for c in graph]",
            "\tbfs = [0]",
            "\tfor node in bfs:",
            "\t\tbfs += graph[node]",
            "\t\tfor nei in graph[node]:",
            "\t\t\tgraph[nei].remove(node)",
            "\tsize = [0] * n",
            "\tfor node in reversed(bfs):",
            "\t\tsize[node] = 1 + sum(size[child] for child in graph[node])",
            "\tdecomposition_tree = [[] for _ in range(n)]",
            "\tdef centroid_reroot(u):",
            "\t\tN = size[u]",
            "\t\twhile True:",
            "\t\t\tfor v in graph[u]:",
            "\t\t\t\tif size[v] > N // 2:",
            "\t\t\t\t\tsize[u] = N - size[v]",
            "\t\t\t\t\tgraph[u].remove(v)",
            "\t\t\t\t\tgraph[v].append(u)",
            "\t\t\t\t\tu = v",
            "\t\t\t\t\tbreak",
            "\t\t\telse:",
            "\t\t\t\tdecomposition_tree[u] = [centroid_reroot(v) for v in graph[u]]",
            "\t\t\t\treturn u",
            "\tdecomposition_root = centroid_reroot(0)",
            "\treturn decomposition_tree, decomposition_root"
        ],
        "description": "graph_decom implementation"
    },
    "dpopt": {
        "prefix": "dpopt",
        "body": [
            "def Knuths(n,C = lambda x: x):",
            "\t# conditions",
            "\t# For all a<=b<=c<=d:",
            "\t#\t cost(a,c)+cost(b,d)<=cost(a,d)+cost(b,c)",
            "\t# opt[l][r-1] <= opt[l][r] <= opt[l+1][r]",
            "\tdp = [[0]*n for _ in range(n)]",
            "\topt = [[0]*n for _ in range(n)]",
            "\tfor i in range(n):",
            "\t\tdp[i][i] = 0",
            "\t\topt[i][i] = i",
            "\tfor i in range(n-2,-1,-1):",
            "\t\tfor j in range(i+1,n):",
            "\t\t\tcost = C(i, j)",
            "\t\t\tmini = float('inf')",
            "\t\t\tL = opt[i][j-1]",
            "\t\t\tR = min(j-1, opt[i+1][j])",
            "\t\t\tfor k in range(L, R+1):",
            "\t\t\t\tval = dp[i][k] + dp[k+1][j] + cost",
            "\t\t\t\tif val<=mini:",
            "\t\t\t\t\tmini = val",
            "\t\t\t\t\topt[i][j] = k",
            "\t\t\tdp[i][j] = mini",
            "\treturn dp[0][n-1]",
            "",
            "def DnC(prev, dp, cost):",
            "\t# conditions",
            "\t# opt[i][j] <= opt[i][j+1]",
            "",
            "\t# for i in range(1, K + 1):",
            "\t#\t DnC(dp_prev, dp_cur, cost, n)",
            "\t#\t dp_prev, dp_cur = dp_cur, dp_prev",
            "\tdef solve(l, r, opt_l, opt_r):",
            "\t\tif l > r:",
            "\t\t\treturn",
            "",
            "\t\tmid = (l + r) // 2",
            "\t\tbest_k = -1",
            "\t\tbest_val = float('inf')",
            "\t\tend = max(0,min(mid - 1, opt_r))",
            "\t\tfor k in range(opt_l, end + 1):",
            "\t\t\tval = prev[k] + cost(k, mid)",
            "\t\t\tif val < best_val:",
            "\t\t\t\tbest_val = val",
            "\t\t\t\tbest_k = k",
            "\t\tdp[mid] = best_val",
            "\t\tsolve(l, mid - 1, opt_l, best_k)",
            "\t\tsolve(mid + 1, r, best_k, opt_r)",
            "\tsolve(0,len(dp)-1,0,len(dp)-1)"
        ],
        "description": "dpopt implementation"
    },
    
    "rbdsu": {
        "prefix": "rbdsu",
        "body": [
            "class RollbackDSU:",
            "\tdef __init__(self,n):",
            "\t\tself.p=list(range(n)); self.sz=[1]*n; self.st=[]",
            "\tdef find(self,x):",
            "\t\twhile x!=self.p[x]: x=self.p[x]",
            "\t\treturn x",
            "\tdef union(self,a,b):",
            "\t\ta,b=self.find(a),self.find(b)",
            "\t\tif a==b: self.st.append((-1,-1,-1)); return",
            "\t\tif self.sz[a]>self.sz[b]: a,b=b,a",
            "\t\tself.st.append((a,b,self.sz[b]))",
            "\t\tself.p[a]=b; self.sz[b]+=self.sz[a]",
            "\tdef rollback(self):",
            "\t\ta,b,s=self.st.pop()",
            "\t\tif a==-1: return",
            "\t\tself.p[a]=a; self.sz[b]=s",
            "",
            "class ParPersistentDSU:",
            "\t# Partially Persistent DSU with no branching",
            "\tdef __init__(self,n):",
            "\t\tself.parent = list(range(n))",
            "\t\tself.size = [1]*n",
            "\t\tself.time = [float('inf')]*n",
            "\tdef find(self,node,version):",
            "\t\t# returns root at given version",
            "\t\twhile not (self.parent[node]==node or self.time[node]>version):",
            "\t\t\tnode = self.parent[node]",
            "\t\treturn node",
            "\tdef union(self,a,b,time):",
            "\t\t# merges a and b",
            "\t\ta = self.find(a,time)",
            "\t\tb = self.find(b,time)",
            "\t\tif a==b:",
            "\t\t\treturn False",
            "\t\tif self.size[a]>self.size[b]:",
            "\t\t\ta,b = b,a",
            "\t\tself.parent[a] = b",
            "\t\tself.time[a] = time",
            "\t\tself.size[b] += self.size[a]",
            "\t\treturn True",
            "\tdef isconnected(self,a,b,time):",
            "\t\treturn self.find(a,time)==self.find(b,time)"
        ],
        "description": "rbdsu implementation"
    },
        
    "seg2d": {
        "prefix": "seg2d",
        "body": [
            "class SegTree2DInlined:",
            "\tdef __init__(self, a, combine, modify_op, identity):",
            "\t\tself.n = len(a)",
            "\t\tself.m = len(a[0])",
            "\t\tself.vals = (",
            "\t\t\t[[identity]*(2*self.m) for _ in range(self.n)] +",
            "\t\t\t[[identity]*self.m + row for row in a]",
            "\t\t)",
            "\t\tfor i in range(self.n, 2*self.n):",
            "\t\t\tbar = self.vals[i]",
            "\t\t\tfor j in reversed(range(1, self.m)):",
            "\t\t\t\tbar[j] = combine(bar[j<<1], bar[j<<1|1])",
            "\t\tfor i in reversed(range(1, self.n)):",
            "\t\t\tbar = self.vals[i]",
            "\t\t\tlbar = self.vals[i<<1]",
            "\t\t\trbar = self.vals[i<<1|1]",
            "\t\t\tfor j in range(1, 2*self.m):",
            "\t\t\t\tbar[j] = combine(lbar[j], rbar[j])",
            "\t\tself.combine = combine",
            "\t\tself.modify_op = modify_op",
            "\t\tself.identity = identity",
            "",
            "",
            "\tdef modify(self, i, j, x):",
            "\t\ti += self.n",
            "\t\tj0 = j + self.n",
            "\t\tbasebar = self.vals[i]",
            "\t\tbasebar[j0] = self.modify_op(basebar[j0], x)",
            "\t\tj = j0 // 2",
            "\t\twhile j:",
            "\t\t\tbasebar[j] = self.combine(basebar[j<<1], basebar[j<<1|1])",
            "\t\t\tj //= 2",
            "\t\ti //= 2",
            "\t\twhile i:",
            "\t\t\tbar = self.vals[i]",
            "\t\t\tlbar = self.vals[i<<1]",
            "\t\t\trbar = self.vals[i<<1|1]",
            "\t\t\tj = j0",
            "\t\t\twhile j:",
            "\t\t\t\tbar[j] = self.combine(lbar[j], rbar[j])",
            "\t\t\t\tj //= 2",
            "\t\t\ti //= 2",
            "",
            "\tdef _get_tour(self, l, r):",
            "\t\tl += self.n",
            "\t\tr += self.n",
            "\t\tltour = []",
            "\t\trtour = []",
            "\t\twhile l < r:",
            "\t\t\tif l & 1:",
            "\t\t\t\tltour.append(l)",
            "\t\t\t\tl += 1",
            "\t\t\tif r & 1:",
            "\t\t\t\tr -= 1",
            "\t\t\t\trtour.append(r)",
            "\t\t\tl //= 2",
            "\t\t\tr //= 2",
            "\t\trtour.reverse()",
            "\t\treturn ltour + rtour",
            "",
            "\t# [i,I) [j,J)",
            "\tdef query(self, i, j, I, J):",
            "\t\ttour = self._get_tour(j, J)",
            "\t\tif i == I or j == J:",
            "\t\t\treturn self.identity",
            "\t\tu = i + self.n",
            "\t\td = I + self.n",
            "",
            "\t\tret = self.identity",
            "\t\twhile u < d:",
            "\t\t\tif u & 1:",
            "\t\t\t\tbar = self.vals[u]",
            "\t\t\t\tfor pos in tour:",
            "\t\t\t\t\tret = self.combine(ret, bar[pos])",
            "\t\t\t\tu += 1",
            "\t\t\tif d & 1:",
            "\t\t\t\td -= 1",
            "\t\t\t\tbar = self.vals[d]",
            "\t\t\t\tfor pos in tour:",
            "\t\t\t\t\tret = self.combine(ret, bar[pos])",
            "\t\t\tu //= 2",
            "\t\t\td //= 2",
            "",
            "\t\treturn ret"
        ],
        "description": "seg2d implementation"
    }
}